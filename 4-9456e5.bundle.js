(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[4],{

/***/ "./node_modules/@fancyapps/ui/dist/fancybox.css":
/*!******************************************************!*\
  !*** ./node_modules/@fancyapps/ui/dist/fancybox.css ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n    if(true) {\n      // 1628131096266\n      var cssReload = __webpack_require__(/*! ./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js */ \"./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.i, {\"locals\":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  \n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/dist/fancybox.css?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Carousel/Carousel.js":
/*!*************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/Carousel.js ***!
  \*************************************************************/
/*! exports provided: Carousel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Carousel\", function() { return Carousel; });\n/* harmony import */ var _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/Base/Base.js */ \"./node_modules/@fancyapps/ui/src/shared/Base/Base.js\");\n/* harmony import */ var _Panzoom_Panzoom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Panzoom/Panzoom.js */ \"./node_modules/@fancyapps/ui/src/Panzoom/Panzoom.js\");\n/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils/extend.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/extend.js\");\n/* harmony import */ var _shared_utils_round_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/utils/round.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/round.js\");\n/* harmony import */ var _shared_utils_throttle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/utils/throttle.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/throttle.js\");\n/* harmony import */ var _plugins_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/index.js */ \"./node_modules/@fancyapps/ui/src/Carousel/plugins/index.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst defaults = {\r\n  // Virtual slides. Each object should have at least `html` property that will be used to set content,\r\n  // example: `slides: [{html: 'First slide'}, {html: 'Second slide'}]`\r\n  slides: [],\r\n\r\n  // Number of slides to preload before/after visible slides\r\n  preload: 0,\r\n\r\n  // Number of slides to group into the page,\r\n  // if `auto` - group all slides that fit into the viewport\r\n  slidesPerPage: \"auto\",\r\n\r\n  // Index of initial page\r\n  initialPage: 0,\r\n\r\n  // Panzoom friction while changing page\r\n  friction: 0.92,\r\n\r\n  // Should center active page\r\n  center: true,\r\n\r\n  // Should carousel scroll infinitely\r\n  infinite: true,\r\n\r\n  // Should the gap be filled before first and after last slide if `infinite: false`\r\n  fill: true,\r\n\r\n  // Should Carousel settle at any position after a swipe.\r\n  dragFree: false,\r\n\r\n  classNames: {\r\n    viewport: \"carousel__viewport\",\r\n    track: \"carousel__track\",\r\n    slide: \"carousel__slide\",\r\n    // Classname toggled for slides inside current page\r\n    slideSelected: \"is-selected\",\r\n  },\r\n\r\n  // Translations\r\n  l10n: {\r\n    NEXT: \"Next slide\",\r\n    PREV: \"Previous slide\",\r\n    GOTO: \"Go to slide %d\",\r\n  },\r\n};\r\n\r\nclass Carousel extends _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"] {\r\n  /**\r\n   * Carousel constructor\r\n   * @constructs Carousel\r\n   * @param {HTMLElement} $element - Carousel container\r\n   * @param {Object} [options] - Options for Carousel\r\n   */\r\n  constructor($element, options = {}) {\r\n    options = Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(true, {}, defaults, options);\r\n\r\n    super(options);\r\n\r\n    this.state = \"init\";\r\n\r\n    this.$element = $element;\r\n\r\n    $element.Carousel = this;\r\n\r\n    this.page = this.pageIndex = null;\r\n    this.prevPage = this.prevPageIndex = null;\r\n\r\n    this.slideNext = Object(_shared_utils_throttle_js__WEBPACK_IMPORTED_MODULE_4__[\"throttle\"])(this.slideNext.bind(this), 250, true);\r\n    this.slidePrev = Object(_shared_utils_throttle_js__WEBPACK_IMPORTED_MODULE_4__[\"throttle\"])(this.slidePrev.bind(this), 250, true);\r\n\r\n    this.attachPlugins(Carousel.Plugins);\r\n\r\n    this.trigger(\"init\");\r\n\r\n    this.initLayout();\r\n\r\n    this.initSlides();\r\n\r\n    this.initPanzoom();\r\n\r\n    this.state = \"ready\";\r\n\r\n    this.trigger(\"ready\");\r\n  }\r\n\r\n  /**\r\n   * Initialize layout; create necessary elements\r\n   */\r\n  initLayout() {\r\n    if (!(this.$element instanceof HTMLElement)) {\r\n      throw new Error(\"No root element provided\");\r\n    }\r\n\r\n    const classNames = this.option(\"classNames\");\r\n\r\n    this.$viewport = this.option(\"viewport\") || this.$element.querySelector(\".\" + classNames.viewport);\r\n\r\n    if (!this.$viewport) {\r\n      this.$viewport = document.createElement(\"div\");\r\n      this.$viewport.classList.add(classNames.viewport);\r\n\r\n      this.$viewport.append(...this.$element.childNodes);\r\n\r\n      this.$element.appendChild(this.$viewport);\r\n    }\r\n\r\n    this.$track = this.option(\"track\") || this.$element.querySelector(\".\" + classNames.track);\r\n\r\n    if (!this.$track) {\r\n      this.$track = document.createElement(\"div\");\r\n      this.$track.classList.add(classNames.track);\r\n\r\n      this.$track.append(...this.$viewport.childNodes);\r\n\r\n      this.$viewport.appendChild(this.$track);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fill `slides` array with objects from existing nodes and/or `slides` option\r\n   */\r\n  initSlides() {\r\n    this.slides = [];\r\n\r\n    // Get existing slides from the DOM\r\n    const elems = this.$viewport.querySelectorAll(\".\" + this.option(\"classNames.slide\"));\r\n\r\n    elems.forEach((el) => {\r\n      const slide = {\r\n        $el: el,\r\n        isDom: true,\r\n      };\r\n\r\n      this.slides.push(slide);\r\n\r\n      this.trigger(\"createSlide\", slide, this.slides.length);\r\n    });\r\n\r\n    // Add virtual slides, but do not create DOM elements yet,\r\n    // because they will be created dynamically based on current carousel position\r\n    if (Array.isArray(this.options.slides)) {\r\n      this.slides = Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(true, [...this.slides], this.options.slides);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recalculate and center current page\r\n   */\r\n  updatePage() {\r\n    let page = this.page;\r\n\r\n    if (page === null) {\r\n      page = this.page = this.option(\"initialPage\");\r\n    }\r\n\r\n    this.updateMetrics();\r\n\r\n    const pages = this.pages;\r\n\r\n    if (!pages[page]) {\r\n      page = pages.length ? pages[pages.length - 1].index : 0;\r\n    }\r\n\r\n    this.slideTo(page, { friction: 0 });\r\n  }\r\n\r\n  /**\r\n   * Tweak panzoom boundaries\r\n   */\r\n  updateBounds() {\r\n    let panzoom = this.Panzoom;\r\n\r\n    // Enable `infinite` options\r\n    const infinite = this.option(\"infinite\");\r\n\r\n    const infiniteX = this.option(\"infiniteX\", infinite);\r\n    const infiniteY = this.option(\"infiniteY\", infinite);\r\n\r\n    if (infiniteX) {\r\n      panzoom.boundX = null;\r\n    }\r\n\r\n    if (infiniteY) {\r\n      panzoom.boundY = null;\r\n    }\r\n\r\n    if (infiniteX || infiniteY) {\r\n      return;\r\n    }\r\n\r\n    // if (this.option(\"center\") && !this.option(\"fill\")) {\r\n    panzoom.boundX = {\r\n      from: this.pages[this.pages.length - 1].left * -1,\r\n      to: this.pages[0].left * -1,\r\n    };\r\n    // }\r\n  }\r\n\r\n  initPanzoom() {\r\n    // Create fresh object containing options for Pazoom instance\r\n    const options = Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(\r\n      true,\r\n      {},\r\n      {\r\n        // Track element will be set as Panzoom $content\r\n        content: this.$track,\r\n\r\n        // Disable any user interaction\r\n        click: false,\r\n        doubleClick: false,\r\n        wheel: false,\r\n        pinchToZoom: false,\r\n\r\n        // Right now, only horizontal navigation is supported\r\n        lockAxis: \"x\",\r\n\r\n        // Make `textSelection` option more easy to customize\r\n        textSelection: () => this.option(\"textSelection\", false),\r\n\r\n        // Disable dragging if content (e.g. all slides) fits inside viewport\r\n        panOnlyZoomed: () => this.option(\"panOnlyZoomed\", this.elemDimWidth < this.wrapDimWidth),\r\n\r\n        on: {\r\n          // Bubble events\r\n          \"*\": (name, ...details) => this.trigger(`Panzoom.${name}`, ...details),\r\n\r\n          // Expose panzoom instance as soon as possible\r\n          init: (panzoom) => (this.Panzoom = panzoom),\r\n\r\n          // The rest of events to be processed\r\n          updateMetrics: () => {\r\n            this.updatePage();\r\n          },\r\n          updateBounds: () => {\r\n            this.updateBounds();\r\n          },\r\n          beforeTransform: this.onBeforeTransform.bind(this),\r\n          afterAnimate: this.onAfterAnimate.bind(this),\r\n          touchEnd: this.onTouchEnd.bind(this),\r\n        },\r\n      },\r\n      this.option(\"Panzoom\")\r\n    );\r\n\r\n    // Create new Panzoom instance\r\n    new _Panzoom_Panzoom_js__WEBPACK_IMPORTED_MODULE_1__[\"Panzoom\"](this.$viewport, options);\r\n  }\r\n\r\n  /**\r\n   * Process `Panzoom.beforeTransform` event to remove slides moved out of viewport and\r\n   * to create necessary ones\r\n   */\r\n  onBeforeTransform() {\r\n    if (this.option(\"infiniteX\", this.option(\"infinite\"))) {\r\n      this.manageInfiniteTrack();\r\n    }\r\n\r\n    this.manageSlideVisiblity();\r\n  }\r\n\r\n  /**\r\n   * Process `Panzoom.afterAnimate` event\r\n   * @param {Object} panzoom\r\n   * @param {Boolean} [isInstant=false]\r\n   */\r\n  onAfterAnimate(panzoom, isInstant) {\r\n    // If `isInstant === true` then it means the position is set without any animation\r\n    if (!isInstant) {\r\n      this.trigger(\"settle\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process `Panzoom.touchEnd` event; slide to next/prev page if needed\r\n   * @param {object} panzoom\r\n   */\r\n  onTouchEnd(panzoom) {\r\n    const dragFree = this.option(\"dragFree\");\r\n\r\n    // If this is a quick horizontal flick, slide to next/prev slide\r\n    if (\r\n      !dragFree &&\r\n      this.pages.length > 1 &&\r\n      panzoom.drag.elapsedTime < 350 &&\r\n      Math.abs(panzoom.drag.distanceY) < 1 &&\r\n      Math.abs(panzoom.drag.distanceX) > 5\r\n    ) {\r\n      this[panzoom.drag.distanceX < 0 ? \"slideNext\" : \"slidePrev\"]();\r\n      return;\r\n    }\r\n\r\n    // Set the slide at the end of the animation as the current one,\r\n    // or slide to closest page\r\n    if (dragFree) {\r\n      const [, nextPageIndex] = this.getPageFromPosition(this.Panzoom.pan.x * -1);\r\n      this.setPage(nextPageIndex);\r\n    } else {\r\n      this.slideToClosest();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Seamlessly flips position of infinite carousel, if needed; this way x position stays low\r\n   */\r\n  manageInfiniteTrack() {\r\n    if (\r\n      !this.option(\"infiniteX\", this.option(\"infinite\")) ||\r\n      this.pages.length < 2 ||\r\n      this.elemDimWidth < this.wrapDimWidth\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const panzoom = this.Panzoom;\r\n\r\n    let isFlipped = false;\r\n\r\n    if (panzoom.current.x < (panzoom.contentDim.width - panzoom.viewportDim.width) * -1) {\r\n      panzoom.current.x += panzoom.contentDim.width;\r\n\r\n      if (panzoom.drag.firstPosition) {\r\n        panzoom.drag.firstPosition.x += panzoom.contentDim.width;\r\n      }\r\n\r\n      this.pageIndex = this.pageIndex - this.pages.length;\r\n\r\n      isFlipped = true;\r\n    }\r\n\r\n    if (panzoom.current.x > panzoom.viewportDim.width) {\r\n      panzoom.current.x -= panzoom.contentDim.width;\r\n\r\n      if (panzoom.drag.firstPosition) {\r\n        panzoom.drag.firstPosition.x -= panzoom.contentDim.width;\r\n      }\r\n\r\n      this.pageIndex = this.pageIndex + this.pages.length;\r\n\r\n      isFlipped = true;\r\n    }\r\n\r\n    if (isFlipped && panzoom.state === \"dragging\") {\r\n      panzoom.resetDragState();\r\n    }\r\n\r\n    return isFlipped;\r\n  }\r\n\r\n  /**\r\n   * Creates or moves existing slides that are visible or should be preloaded,\r\n   * removes unnecessary virtual slides\r\n   */\r\n  manageSlideVisiblity() {\r\n    const contentWidth = this.elemDimWidth;\r\n    const viewportWidth = this.wrapDimWidth;\r\n\r\n    let currentX = this.Panzoom.current.x * -1;\r\n\r\n    if (Math.abs(currentX) < 0.1) {\r\n      currentX = 0;\r\n    }\r\n\r\n    const preload = this.option(\"preload\");\r\n    const infinite = this.option(\"infiniteX\", this.option(\"infinite\"));\r\n\r\n    const paddingLeft = parseFloat(window.getComputedStyle(this.$viewport, null).getPropertyValue(\"padding-left\"));\r\n    const paddingRight = parseFloat(window.getComputedStyle(this.$viewport, null).getPropertyValue(\"padding-right\"));\r\n\r\n    // Check visibility of each slide\r\n    this.slides.forEach((slide) => {\r\n      let leftBoundary, rightBoundary;\r\n\r\n      let hasDiff = 0;\r\n\r\n      // #1 - slides in current viewport; this does not include infinite items\r\n      leftBoundary = currentX - paddingLeft;\r\n      rightBoundary = currentX + viewportWidth + paddingRight;\r\n\r\n      leftBoundary -= preload * (viewportWidth + paddingLeft + paddingRight);\r\n      rightBoundary += preload * (viewportWidth + paddingLeft + paddingRight);\r\n\r\n      const insideCurrentInterval = slide.left + slide.width > leftBoundary && slide.left < rightBoundary;\r\n\r\n      // #2 - infinite items inside current viewport; from previous interval\r\n      leftBoundary = currentX + contentWidth - paddingLeft;\r\n      rightBoundary = currentX + contentWidth + viewportWidth + paddingRight;\r\n\r\n      // Include slides that have to be preloaded\r\n      leftBoundary -= preload * (viewportWidth + paddingLeft + paddingRight);\r\n\r\n      const insidePrevInterval = infinite && slide.left + slide.width > leftBoundary && slide.left < rightBoundary;\r\n\r\n      // #2 - infinite items inside current viewport; from next interval\r\n      leftBoundary = currentX - contentWidth - paddingLeft;\r\n      rightBoundary = currentX - contentWidth + viewportWidth + paddingRight;\r\n\r\n      // Include slides that have to be preloaded\r\n      leftBoundary -= preload * (viewportWidth + paddingLeft + paddingRight);\r\n\r\n      const insideNextInterval = infinite && slide.left + slide.width > leftBoundary && slide.left < rightBoundary;\r\n\r\n      // Create virtual slides that should be visible or preloaded, remove others\r\n      if (insidePrevInterval || insideCurrentInterval || insideNextInterval) {\r\n        this.createSlideEl(slide);\r\n\r\n        if (insideCurrentInterval) {\r\n          hasDiff = 0;\r\n        }\r\n\r\n        if (insidePrevInterval) {\r\n          hasDiff = -1;\r\n        }\r\n\r\n        if (insideNextInterval) {\r\n          hasDiff = 1;\r\n        }\r\n\r\n        // Bring preloaded slides back to viewport, if needed\r\n        if (slide.left + slide.width > currentX && slide.left <= currentX + viewportWidth + paddingRight) {\r\n          hasDiff = 0;\r\n        }\r\n      } else {\r\n        this.removeSlideEl(slide);\r\n      }\r\n\r\n      slide.hasDiff = hasDiff;\r\n    });\r\n\r\n    // Reposition slides for continuity\r\n    let nextIndex = 0;\r\n    let nextPos = 0;\r\n\r\n    this.slides.forEach((slide, index) => {\r\n      let updatedX = 0;\r\n\r\n      if (slide.$el) {\r\n        if (index !== nextIndex || slide.hasDiff) {\r\n          //} || slide.hasDiff !== undefined) {\r\n          updatedX = nextPos + slide.hasDiff * contentWidth;\r\n        } else {\r\n          nextPos = 0;\r\n        }\r\n\r\n        slide.$el.style.left = Math.abs(updatedX) > 0.1 ? `${nextPos + slide.hasDiff * contentWidth}px` : \"\";\r\n\r\n        nextIndex++;\r\n      } else {\r\n        nextPos += slide.width;\r\n      }\r\n    });\r\n\r\n    // Update content height to avoid double firing of resize event callback\r\n    this.Panzoom.viewportDim.height = this.Panzoom.$content.clientHeight;\r\n\r\n    this.markSelectedSlides();\r\n  }\r\n\r\n  /**\r\n   * Toggles selected class name and aria-hidden attribute for slides based on visibility\r\n   */\r\n  markSelectedSlides() {\r\n    const selectedClass = this.option(\"classNames.slideSelected\");\r\n    const attr = \"aria-hidden\";\r\n\r\n    this.slides.forEach((slide, index) => {\r\n      const $el = slide.$el;\r\n\r\n      if (!$el) {\r\n        return;\r\n      }\r\n\r\n      const page = this.pages[this.page];\r\n\r\n      if (page && page.indexes && page.indexes.indexOf(index) > -1) {\r\n        if (selectedClass && !$el.classList.contains(selectedClass)) {\r\n          $el.classList.add(selectedClass);\r\n          this.trigger(\"selectSlide\", slide);\r\n        }\r\n\r\n        $el.removeAttribute(attr);\r\n      } else {\r\n        if (selectedClass && $el.classList.contains(selectedClass)) {\r\n          $el.classList.remove(selectedClass);\r\n          this.trigger(\"unselectSlide\", slide);\r\n        }\r\n\r\n        $el.setAttribute(attr, true);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates main DOM element for virtual slides,\r\n   * lazy loads images inside regular slides\r\n   * @param {Object} slide\r\n   */\r\n  createSlideEl(slide) {\r\n    if (!slide) {\r\n      return;\r\n    }\r\n\r\n    if (slide.$el) {\r\n      let curentIndex = parseInt(slide.$el.dataset.index, 10);\r\n\r\n      if (curentIndex !== slide.index) {\r\n        slide.$el.dataset.index = slide.index;\r\n\r\n        // Lazy load images\r\n        const $lazyNodes = slide.$el.querySelectorAll(\"[data-lazy-src]\");\r\n\r\n        $lazyNodes.forEach((node) => {\r\n          let lazySrc = node.dataset.lazySrc;\r\n\r\n          if (node instanceof HTMLImageElement) {\r\n            node.src = lazySrc;\r\n          } else {\r\n            node.style.backgroundImage = `url('${lazySrc}')`;\r\n          }\r\n        });\r\n\r\n        let lazySrc;\r\n\r\n        if ((lazySrc = slide.$el.dataset.lazySrc)) {\r\n          slide.$el.style.backgroundImage = `url('${lazySrc}')`;\r\n        }\r\n\r\n        slide.state = \"ready\";\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    const div = document.createElement(\"div\");\r\n\r\n    div.dataset.index = slide.index;\r\n    div.classList.add(this.option(\"classNames.slide\"));\r\n\r\n    if (slide.customClass) {\r\n      div.classList.add(...slide.customClass.split(\" \"));\r\n    }\r\n\r\n    if (slide.html) {\r\n      div.innerHTML = slide.html;\r\n    }\r\n\r\n    const allElelements = [];\r\n\r\n    this.slides.forEach((slide, index) => {\r\n      if (slide.$el) {\r\n        allElelements.push(index);\r\n      }\r\n    });\r\n\r\n    // Find a place in DOM to insert an element\r\n    const goal = slide.index;\r\n    let refSlide = null;\r\n\r\n    if (allElelements.length) {\r\n      let refIndex = allElelements.reduce((prev, curr) =>\r\n        Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev\r\n      );\r\n      refSlide = this.slides[refIndex];\r\n    }\r\n\r\n    this.$track.insertBefore(\r\n      div,\r\n      refSlide && refSlide.$el ? (refSlide.index < slide.index ? refSlide.$el.nextSibling : refSlide.$el) : null\r\n    );\r\n\r\n    slide.$el = div;\r\n\r\n    this.trigger(\"createSlide\", slide, goal);\r\n\r\n    return slide;\r\n  }\r\n\r\n  /**\r\n   * Calculate slide element width (including left, right margins)\r\n   * @param {Object} node\r\n   * @returns {Number} Width in px\r\n   */\r\n  getSlideMetrics(node) {\r\n    if (!node) {\r\n      const firstSlide = this.slides[0];\r\n\r\n      node = document.createElement(\"div\");\r\n\r\n      node.dataset.isTestEl = 1;\r\n      node.style.visibility = \"hidden\";\r\n      node.classList.add(this.option(\"classNames.slide\"));\r\n\r\n      // Assume all slides have the same custom class, if any\r\n      if (firstSlide.customClass) {\r\n        node.classList.add(...firstSlide.customClass.split(\" \"));\r\n      }\r\n\r\n      this.$track.prepend(node);\r\n    }\r\n\r\n    let width = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_3__[\"round\"])(node.getBoundingClientRect().width);\r\n\r\n    // Add left/right margin\r\n    const style = node.currentStyle || window.getComputedStyle(node);\r\n    width = width + (parseFloat(style.marginLeft) || 0) + (parseFloat(style.marginRight) || 0);\r\n    // width = node.clientWidth;\r\n    // Proportionally scale if viewport is scaled (mobile devices)\r\n    if (window.visualViewport) {\r\n      width *= window.visualViewport.scale;\r\n    }\r\n\r\n    if (node.dataset.isTestEl) {\r\n      node.remove();\r\n    }\r\n\r\n    return width;\r\n  }\r\n\r\n  /**\r\n   * Calculate dimensions of all slides and fill pages\r\n   */\r\n  updateMetrics() {\r\n    let totalWidth = 0;\r\n    let indexes = [];\r\n    let lastSlideWidth;\r\n\r\n    this.slides.forEach((slide, index) => {\r\n      const $el = slide.$el;\r\n\r\n      const slideWidth = slide.isDom || !lastSlideWidth ? this.getSlideMetrics($el) : lastSlideWidth;\r\n\r\n      slide.index = index;\r\n      slide.width = slideWidth;\r\n      slide.left = totalWidth;\r\n\r\n      lastSlideWidth = slideWidth;\r\n      totalWidth += slideWidth;\r\n\r\n      indexes.push(index);\r\n    });\r\n\r\n    this.elemDimWidth = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_3__[\"round\"])(totalWidth);\r\n    this.Panzoom.contentDim.width = this.elemDimWidth;\r\n\r\n    this.wrapDimWidth = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_3__[\"round\"])(this.$viewport.getBoundingClientRect().width);\r\n\r\n    var styles = window.getComputedStyle(this.$viewport);\r\n    var padding = parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);\r\n\r\n    this.wrapDimWidth = this.wrapDimWidth - padding;\r\n\r\n    if (window.visualViewport) {\r\n      this.wrapDimWidth *= window.visualViewport.scale;\r\n    }\r\n\r\n    this.Panzoom.viewportDim.width = this.wrapDimWidth;\r\n\r\n    const pages = [];\r\n    const slidesPerPage = this.option(\"slidesPerPage\");\r\n\r\n    // Split slides into pages\r\n    if (Number.isInteger(slidesPerPage) && this.elemDimWidth > this.wrapDimWidth) {\r\n      // Fixed number of slides in the page\r\n      for (let i = 0; i < this.slides.length; i += slidesPerPage) {\r\n        pages.push({\r\n          indexes: indexes.slice(i, i + slidesPerPage),\r\n          slides: this.slides.slice(i, i + slidesPerPage),\r\n        });\r\n      }\r\n    } else {\r\n      // Slides that fit inside viewport\r\n      let currentPage = 0;\r\n      let currentWidth = 0;\r\n\r\n      for (let i = 0; i < this.slides.length; i += 1) {\r\n        let slide = this.slides[i];\r\n\r\n        // Add next page\r\n        if (!pages.length || currentWidth + slide.width > this.wrapDimWidth) {\r\n          pages.push({\r\n            indexes: [],\r\n            slides: [],\r\n          });\r\n\r\n          currentPage = pages.length - 1;\r\n          currentWidth = 0;\r\n        }\r\n\r\n        currentWidth += slide.width;\r\n\r\n        pages[currentPage].indexes.push(i);\r\n        pages[currentPage].slides.push(slide);\r\n      }\r\n    }\r\n\r\n    const shouldCenter = this.option(\"center\");\r\n    const shouldFill = this.option(\"fill\");\r\n\r\n    // Calculate width and start position for each page\r\n    pages.forEach((page, index) => {\r\n      page.index = index;\r\n      page.width = page.slides.reduce((sum, slide) => sum + slide.width, 0);\r\n\r\n      page.left = page.slides[0].left;\r\n\r\n      if (shouldCenter) {\r\n        page.left += (this.wrapDimWidth - page.width) * 0.5 * -1;\r\n      }\r\n\r\n      if (shouldFill && !this.option(\"infiniteX\", this.option(\"infinite\")) && this.elemDimWidth > this.wrapDimWidth) {\r\n        page.left = Math.max(page.left, 0);\r\n        page.left = Math.min(page.left, this.elemDimWidth - this.wrapDimWidth);\r\n      }\r\n    });\r\n\r\n    const rez = [];\r\n    let prevPage;\r\n\r\n    pages.forEach((page) => {\r\n      if (prevPage && page.left === prevPage.left) {\r\n        prevPage.width += page.width;\r\n\r\n        prevPage.slides = [...prevPage.slides, ...page.slides];\r\n        prevPage.indexes = [...prevPage.indexes, ...page.indexes];\r\n      } else {\r\n        page.index = rez.length;\r\n\r\n        prevPage = page;\r\n\r\n        rez.push(page);\r\n      }\r\n    });\r\n\r\n    this.pages = rez;\r\n\r\n    this.manageSlideVisiblity();\r\n\r\n    this.trigger(\"refresh\");\r\n  }\r\n\r\n  /**\r\n   * Changes active page\r\n   * @param {Number} page - New index of active page\r\n   * @param {Boolean} toClosest - to closest page based on scroll distance (for infinite navigation)\r\n   */\r\n  setPage(page, toClosest) {\r\n    let nextPosition = 0;\r\n    let pageIndex = parseInt(page, 10) || 0;\r\n\r\n    const prevPage = this.page,\r\n      prevPageIndex = this.pageIndex,\r\n      pageCount = this.pages.length;\r\n\r\n    page = ((pageIndex % pageCount) + pageCount) % pageCount;\r\n\r\n    if (this.option(\"infiniteX\", this.option(\"infinite\")) && this.elemDimWidth > this.wrapDimWidth) {\r\n      const nextInterval = Math.floor(pageIndex / pageCount) || 0,\r\n        elemDimWidth = this.elemDimWidth;\r\n\r\n      nextPosition = this.pages[page].left + nextInterval * elemDimWidth;\r\n\r\n      if (toClosest === true && pageCount > 2) {\r\n        let currPosition = this.Panzoom.current.x * -1;\r\n\r\n        // * Find closest interval\r\n        const decreasedPosition = nextPosition - elemDimWidth,\r\n          increasedPosition = nextPosition + elemDimWidth,\r\n          diff1 = Math.abs(currPosition - nextPosition),\r\n          diff2 = Math.abs(currPosition - decreasedPosition),\r\n          diff3 = Math.abs(currPosition - increasedPosition);\r\n\r\n        if (diff3 < diff1 && diff3 <= diff2) {\r\n          nextPosition = increasedPosition;\r\n          pageIndex += pageCount;\r\n        } else if (diff2 < diff1 && diff2 < diff3) {\r\n          nextPosition = decreasedPosition;\r\n          pageIndex -= pageCount;\r\n        }\r\n      }\r\n    } else {\r\n      page = pageIndex = Math.max(0, Math.min(pageIndex, pageCount - 1));\r\n\r\n      nextPosition = this.pages[page].left;\r\n    }\r\n\r\n    this.page = page;\r\n    this.pageIndex = pageIndex;\r\n\r\n    if (prevPage !== null && page !== prevPage) {\r\n      this.prevPage = prevPage;\r\n      this.prevPageIndex = prevPageIndex;\r\n\r\n      this.trigger(\"change\", page, prevPage);\r\n    }\r\n\r\n    return nextPosition;\r\n  }\r\n\r\n  /**\r\n   * Slides carousel to given page\r\n   * @param {Number} page - New index of active page\r\n   * @param {Object} [params] - Additional options\r\n   */\r\n  slideTo(page, params = {}) {\r\n    const { friction = this.option(\"friction\") } = params;\r\n\r\n    this.Panzoom.panTo({ x: this.setPage(page, true) * -1, y: 0, friction });\r\n  }\r\n\r\n  /**\r\n   * Slides to the closest page (useful, if carousel is changed manually)\r\n   * @param {Object} [params] - Object containing additional options\r\n   */\r\n  slideToClosest(params = {}) {\r\n    let [, nextPageIndex] = this.getPageFromPosition(this.Panzoom.pan.x * -1);\r\n\r\n    this.slideTo(nextPageIndex, params);\r\n  }\r\n\r\n  /**\r\n   * Slide to next page, if possible\r\n   */\r\n  slideNext() {\r\n    this.slideTo(this.pageIndex + 1);\r\n  }\r\n\r\n  /**\r\n   * Slide to previous page, if possible\r\n   */\r\n  slidePrev() {\r\n    this.slideTo(this.pageIndex - 1);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Integer} index Index of the slide\r\n   * @returns {Integer|null} Index of the page if found, or null\r\n   */\r\n  getPageforSlide(index) {\r\n    const page = this.pages.find((page) => {\r\n      return page.indexes.indexOf(index) > -1;\r\n    });\r\n\r\n    return page ? page.index : null;\r\n  }\r\n\r\n  /**\r\n   * Returns index of closest page to given x position\r\n   * @param {Number} xPos\r\n   */\r\n  getPageFromPosition(xPos) {\r\n    const pageCount = this.pages.length;\r\n    const center = this.option(\"center\");\r\n\r\n    if (center) {\r\n      xPos += this.wrapDimWidth * 0.5;\r\n    }\r\n\r\n    const interval = Math.floor(xPos / this.elemDimWidth);\r\n\r\n    xPos -= interval * this.elemDimWidth;\r\n\r\n    let slide = this.slides.find((slide) => slide.left < xPos && slide.left + slide.width > xPos);\r\n\r\n    if (slide) {\r\n      let pageIndex = this.getPageforSlide(slide.index);\r\n\r\n      return [pageIndex, pageIndex + interval * pageCount];\r\n    }\r\n\r\n    return [0, 0];\r\n  }\r\n\r\n  /**\r\n   * Removes main DOM element of given slide\r\n   * @param {Object} slide\r\n   */\r\n  removeSlideEl(slide) {\r\n    if (slide.$el && !slide.isDom) {\r\n      this.trigger(\"deleteSlide\", slide);\r\n\r\n      slide.$el.remove();\r\n      slide.$el = null;\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    this.state = \"destroy\";\r\n\r\n    this.slides.forEach((slide) => {\r\n      this.removeSlideEl(slide);\r\n    });\r\n\r\n    this.Panzoom.destroy();\r\n\r\n    this.options = {};\r\n    this.events = {};\r\n  }\r\n}\r\n\r\n// Expose version\r\nCarousel.version = \"__VERSION__\";\r\n\r\n// Static properties are a recent addition that dont work in all browsers yet\r\nCarousel.Plugins = _plugins_index_js__WEBPACK_IMPORTED_MODULE_5__[\"Plugins\"];\r\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Carousel/Carousel.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Carousel/plugins/Dots/Dots.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/plugins/Dots/Dots.js ***!
  \**********************************************************************/
/*! exports provided: Dots */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dots\", function() { return Dots; });\nclass Dots {\n  constructor(carousel) {\n    this.carousel = carousel;\n\n    this.$list = null;\n\n    this.events = {\n      change: this.onChange.bind(this),\n      refresh: this.onRefresh.bind(this),\n    };\n  }\n\n  /**\n   * Build wrapping DOM element containing all dots\n   */\n  buildList() {\n    if (this.carousel.pages.length < 2) {\n      return;\n    }\n\n    const $list = document.createElement(\"ol\");\n\n    $list.classList.add(\"carousel__dots\");\n\n    $list.addEventListener(\"click\", (e) => {\n      if (!(\"page\" in e.target.dataset)) {\n        return;\n      }\n\n      e.preventDefault();\n      e.stopPropagation();\n\n      const page = parseInt(e.target.dataset.page, 10);\n      const carousel = this.carousel;\n\n      if (page === carousel.page) {\n        return;\n      }\n\n      if (carousel.pages.length < 3 && carousel.option(\"infinite\")) {\n        carousel[page == 0 ? \"slidePrev\" : \"slideNext\"]();\n      } else {\n        carousel.slideTo(page);\n      }\n    });\n\n    this.$list = $list;\n\n    this.carousel.$element.appendChild($list);\n    this.carousel.$element.classList.add(\"has-dots\");\n\n    return $list;\n  }\n\n  /**\n   * Remove wrapping DOM element\n   */\n  removeList() {\n    if (this.$list) {\n      this.$list.parentNode.removeChild(this.$list);\n      this.$list = null;\n    }\n  }\n\n  /**\n   * Remove existing dots and create fresh ones\n   */\n  rebuildDots() {\n    let $list = this.$list;\n\n    const listExists = !!$list;\n    const pagesCount = this.carousel.pages.length;\n\n    if (pagesCount < 2) {\n      if (listExists) {\n        this.removeList();\n      }\n\n      return;\n    }\n\n    if (!listExists) {\n      $list = this.buildList();\n    }\n\n    // Remove existing dots\n    const dotCount = this.$list.children.length;\n\n    if (dotCount > pagesCount) {\n      for (let i = pagesCount; i < dotCount; i++) {\n        this.$list.removeChild(this.$list.lastChild);\n      }\n\n      return;\n    }\n\n    // Create fresh DOM elements (dots) for each page\n    for (let index = dotCount; index < pagesCount; index++) {\n      const $dot = document.createElement(\"li\");\n\n      $dot.classList.add(\"carousel__dot\");\n      $dot.dataset.page = index;\n\n      $dot.setAttribute(\"role\", \"button\");\n      $dot.setAttribute(\"tabindex\", \"0\");\n      $dot.setAttribute(\"title\", this.carousel.localize(\"{{GOTO}}\", [[\"%d\", index + 1]]));\n\n      $dot.addEventListener(\"keydown\", (event) => {\n        const code = event.code;\n\n        let $el;\n\n        if (code === \"Enter\" || code === \"NumpadEnter\") {\n          $el = $dot;\n        } else if (code === \"ArrowRight\") {\n          $el = $dot.nextSibling;\n        } else if (code === \"ArrowLeft\") {\n          $el = $dot.previousSibling;\n        }\n\n        $el && $el.click();\n      });\n\n      this.$list.appendChild($dot);\n    }\n\n    this.setActiveDot();\n  }\n\n  /**\n   * Mark active dot by toggling class name\n   */\n  setActiveDot() {\n    if (!this.$list) {\n      return;\n    }\n\n    this.$list.childNodes.forEach(($dot) => {\n      $dot.classList.remove(\"is-selected\");\n    });\n\n    const $activeDot = this.$list.childNodes[this.carousel.page];\n\n    if ($activeDot) {\n      $activeDot.classList.add(\"is-selected\");\n    }\n  }\n\n  /**\n   * Process carousel `change` event\n   */\n  onChange() {\n    this.setActiveDot();\n  }\n\n  /**\n   * Process carousel `refresh` event\n   */\n  onRefresh() {\n    this.rebuildDots();\n  }\n\n  attach() {\n    this.carousel.on(this.events);\n  }\n\n  detach() {\n    this.removeList();\n\n    this.carousel.off(this.events);\n    this.carousel = null;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Carousel/plugins/Dots/Dots.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Carousel/plugins/Navigation/Navigation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/plugins/Navigation/Navigation.js ***!
  \**********************************************************************************/
/*! exports provided: Navigation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Navigation\", function() { return Navigation; });\nconst defaults = {\n  prevTpl: '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" tabindex=\"-1\"><path d=\"M15 3l-9 9 9 9\"/></svg>',\n  nextTpl: '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" tabindex=\"-1\"><path d=\"M9 3l9 9-9 9\"/></svg>',\n\n  classNames: {\n    main: \"carousel__nav\",\n    button: \"carousel__button\",\n\n    next: \"is-next\",\n    prev: \"is-prev\",\n  },\n};\n\nclass Navigation {\n  constructor(carousel) {\n    this.$container = null;\n\n    this.$prev = null;\n    this.$next = null;\n\n    this.carousel = carousel;\n\n    this.onRefresh = this.onRefresh.bind(this);\n  }\n\n  /**\n   * Shortcut to get option for this plugin\n   * @param {String} name option name\n   * @returns option value\n   */\n  option(name) {\n    return this.carousel.option(`Navigation.${name}`);\n  }\n\n  /**\n   * Creates and returns new button element with default class names and click event\n   * @param {String} type\n   */\n  createButton(type) {\n    const $btn = document.createElement(\"button\");\n\n    $btn.setAttribute(\"title\", this.carousel.localize(`{{${type.toUpperCase()}}}`));\n\n    const classNames = this.option(\"classNames.button\") + \" \" + this.option(`classNames.${type}`);\n\n    $btn.classList.add(...classNames.split(\" \"));\n    $btn.setAttribute(\"tabindex\", \"0\");\n    $btn.innerHTML = this.carousel.localize(this.option(`${type}Tpl`));\n\n    $btn.addEventListener(\"click\", (event) => {\n      event.preventDefault();\n      event.stopPropagation();\n\n      this.carousel[`slide${type === \"next\" ? \"Next\" : \"Prev\"}`]();\n    });\n\n    return $btn;\n  }\n\n  /**\n   * Build necessary DOM elements\n   */\n  build() {\n    if (!this.$container) {\n      this.$container = document.createElement(\"div\");\n      this.$container.classList.add(this.option(\"classNames.main\"));\n\n      this.carousel.$element.appendChild(this.$container);\n    }\n\n    if (!this.$next) {\n      this.$next = this.createButton(\"next\");\n\n      this.$container.appendChild(this.$next);\n    }\n\n    if (!this.$prev) {\n      this.$prev = this.createButton(\"prev\");\n\n      this.$container.appendChild(this.$prev);\n    }\n  }\n\n  /**\n   *  Process carousel `refresh` and `change` events to enable/disable buttons if needed\n   */\n  onRefresh() {\n    const pageCount = this.carousel.pages.length;\n\n    if (\n      pageCount <= 1 ||\n      (pageCount > 1 &&\n        this.carousel.elemDimWidth < this.carousel.wrapDimWidth &&\n        !Number.isInteger(this.carousel.option(\"slidesPerPage\")))\n    ) {\n      this.cleanup();\n\n      return;\n    }\n\n    this.build();\n\n    this.$prev.removeAttribute(\"disabled\");\n    this.$next.removeAttribute(\"disabled\");\n\n    if (this.carousel.option(\"infiniteX\", this.carousel.option(\"infinite\"))) {\n      return;\n    }\n\n    if (this.carousel.page <= 0) {\n      this.$prev.setAttribute(\"disabled\", \"\");\n    }\n\n    if (this.carousel.page >= pageCount - 1) {\n      this.$next.setAttribute(\"disabled\", \"\");\n    }\n  }\n\n  cleanup() {\n    if (this.$prev) {\n      this.$prev.remove();\n    }\n\n    this.$prev = null;\n\n    if (this.$next) {\n      this.$next.remove();\n    }\n\n    this.$next = null;\n\n    if (this.$container) {\n      this.$container.remove();\n    }\n\n    this.$container = null;\n  }\n\n  attach() {\n    this.carousel.on(\"refresh change\", this.onRefresh);\n  }\n\n  detach() {\n    this.carousel.off(\"refresh change\", this.onRefresh);\n\n    this.cleanup();\n  }\n}\n\n// Expose defaults\nNavigation.defaults = defaults;\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Carousel/plugins/Navigation/Navigation.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Carousel/plugins/Sync/Sync.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/plugins/Sync/Sync.js ***!
  \**********************************************************************/
/*! exports provided: Sync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sync\", function() { return Sync; });\n/* harmony import */ var _shared_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/utils/isPlainObject.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js\");\n\n\nconst defaults = {\n  friction: 0.92,\n};\n\nclass Sync {\n  constructor(carousel) {\n    this.nav = carousel;\n\n    this.selectedIndex = null;\n\n    this.onNavReady = this.onNavReady.bind(this);\n    this.onNavClick = this.onNavClick.bind(this);\n    this.onNavCreateSlide = this.onNavCreateSlide.bind(this);\n\n    this.onTargetChange = this.onTargetChange.bind(this);\n  }\n\n  /**\n   * Process main carousel `ready` event; bind events and set initial page\n   */\n  onNavReady() {\n    this.onTargetChange(true);\n\n    this.nav.on(\"createSlide\", this.onNavCreateSlide);\n    this.nav.on(\"Panzoom.updateMetrics\", this.onTargetChange);\n\n    this.nav.Panzoom.on(\"click\", this.onNavClick);\n\n    this.sync.on(\"change\", this.onTargetChange);\n  }\n\n  /**\n   * Process main carousel `createSlide` event\n   * @param {Object} carousel\n   * @param {Object} slide\n   */\n  onNavCreateSlide(carousel, slide) {\n    if (slide.index === this.selectedIndex) {\n      this.markSelectedSlide(slide.index);\n    }\n  }\n\n  /**\n   * Process main carousel `click` event\n   * @param {Object} panzoom\n   * @param {Object} event\n   */\n  onNavClick(panzoom, event) {\n    const clickedNavSlide = event.target.closest(\".carousel__slide\");\n\n    if (!clickedNavSlide) {\n      return;\n    }\n\n    event.preventDefault();\n\n    const selectedNavIndex = parseInt(clickedNavSlide.dataset.index, 10);\n    const selectedSyncPage = this.sync.getPageforSlide(selectedNavIndex);\n\n    if (this.sync.page !== selectedSyncPage) {\n      this.sync.slideTo(selectedSyncPage, { friction: this.nav.option(\"Sync.friction\") });\n    }\n\n    this.markSelectedSlide(selectedNavIndex);\n  }\n\n  /**\n   * Toggle classname for slides that marks currently selected slides\n   * @param {Number} selectedIndex\n   */\n  markSelectedSlide(selectedIndex) {\n    this.selectedIndex = selectedIndex;\n\n    [...this.nav.slides].filter((slide) => slide.$el && slide.$el.classList.remove(\"is-nav-selected\"));\n\n    const slide = this.nav.slides[selectedIndex];\n\n    if (slide && slide.$el) slide.$el.classList.add(\"is-nav-selected\");\n  }\n\n  /**\n   * Process target carousel `change` event\n   * @param {Object} target\n   */\n  onTargetChange(fast) {\n    const targetIndex = this.sync.pages[this.sync.page].indexes[0];\n    const selectedNavPage = this.nav.getPageforSlide(targetIndex);\n\n    if (selectedNavPage === null) return;\n\n    this.nav.slideTo(selectedNavPage, fast === true ? { friction: 0 } : {});\n\n    this.markSelectedSlide(targetIndex);\n  }\n\n  attach() {\n    const sync = this.nav.options.Sync;\n\n    if (!sync) {\n      return;\n    }\n\n    if (Object(_shared_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_0__[\"isPlainObject\"])(sync) && typeof sync.with === \"object\") {\n      this.sync = sync.with;\n    }\n\n    if (this.sync) {\n      this.nav.on(\"ready\", this.onNavReady);\n    }\n  }\n\n  detach() {\n    if (this.sync) {\n      this.nav.off(\"ready\", this.onNavReady);\n      this.nav.off(\"createSlide\", this.onNavCreate);\n      this.nav.on(\"Panzoom.updateMetrics\", this.onTargetChange);\n\n      this.sync.off(\"change\", this.onTargetChange);\n    }\n\n    this.nav.Panzoom.off(\"click\", this.onNavClick);\n\n    this.sync = null;\n    this.selectedIndex = null;\n  }\n}\n\n// Expose defaults\nSync.defaults = defaults;\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Carousel/plugins/Sync/Sync.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Carousel/plugins/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/plugins/index.js ***!
  \******************************************************************/
/*! exports provided: Plugins */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plugins\", function() { return Plugins; });\n/* harmony import */ var _Navigation_Navigation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Navigation/Navigation.js */ \"./node_modules/@fancyapps/ui/src/Carousel/plugins/Navigation/Navigation.js\");\n/* harmony import */ var _Dots_Dots_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dots/Dots.js */ \"./node_modules/@fancyapps/ui/src/Carousel/plugins/Dots/Dots.js\");\n/* harmony import */ var _Sync_Sync_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Sync/Sync.js */ \"./node_modules/@fancyapps/ui/src/Carousel/plugins/Sync/Sync.js\");\n\n\n\n\nconst Plugins = { Navigation: _Navigation_Navigation_js__WEBPACK_IMPORTED_MODULE_0__[\"Navigation\"], Dots: _Dots_Dots_js__WEBPACK_IMPORTED_MODULE_1__[\"Dots\"], Sync: _Sync_Sync_js__WEBPACK_IMPORTED_MODULE_2__[\"Sync\"] };\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Carousel/plugins/index.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/Fancybox.js":
/*!*************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/Fancybox.js ***!
  \*************************************************************/
/*! exports provided: Fancybox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fancybox\", function() { return Fancybox; });\n/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils/extend.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/extend.js\");\n/* harmony import */ var _shared_utils_canUseDOM_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils/canUseDOM.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/canUseDOM.js\");\n/* harmony import */ var _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/Base/Base.js */ \"./node_modules/@fancyapps/ui/src/shared/Base/Base.js\");\n/* harmony import */ var _Carousel_Carousel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Carousel/Carousel.js */ \"./node_modules/@fancyapps/ui/src/Carousel/Carousel.js\");\n/* harmony import */ var _plugins_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/index.js */ \"./node_modules/@fancyapps/ui/src/Fancybox/plugins/index.js\");\n// var global = global || window;\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  // Index of active slide on the start\n  startIndex: 0,\n\n  // Number of slides to preload before and after active slide\n  preload: 1,\n\n  // Should navigation be infinite\n  infinite: true,\n\n  // Class name to be applied to the content to reveal it\n  showClass: \"fancybox-zoomInUp\", // \"fancybox-fadeIn\" | \"fancybox-zoomInUp\" | false\n\n  // Class name to be applied to the content to hide it\n  hideClass: \"fancybox-fadeOut\", // \"fancybox-fadeOut\" | \"fancybox-zoomOutDown\" | false\n\n  // Should backdrop and UI elements fade in/out on start/close\n  animated: true,\n\n  // If browser scrollbar should be hidden\n  hideScrollbar: true,\n\n  // Element containing main structure\n  parentEl: null,\n\n  // Custom class name or multiple space-separated class names for the container\n  mainClass: null,\n\n  // Set focus on first focusable element after displaying content\n  autoFocus: true,\n\n  // Trap focus inside Fancybox\n  trapFocus: true,\n\n  // Set focus back to trigger element after closing Fancybox\n  placeFocusBack: true,\n\n  // Action to take when the user clicks on the backdrop\n  click: \"close\", // \"close\" | \"next\"\n\n  // Position of the close button - over the content or at top right corner of viewport\n  closeButton: \"inside\", // \"inside\" | \"outside\"\n\n  // Allow user to drag content up/down to close instance\n  dragToClose: true,\n\n  // Enable keyboard navigation\n  keyboard: {\n    Escape: \"close\",\n    Delete: \"close\",\n    Backspace: \"close\",\n    PageUp: \"next\",\n    PageDown: \"prev\",\n    ArrowUp: \"next\",\n    ArrowDown: \"prev\",\n    ArrowRight: \"next\",\n    ArrowLeft: \"prev\",\n  },\n\n  // HTML templates for various elements\n  template: {\n    // Close button icon\n    closeButton:\n      '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" tabindex=\"-1\"><path d=\"M20 20L4 4m16 0L4 20\"/></svg>',\n    // Loading indicator icon\n    spinner:\n      '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"50\" height=\"50\" viewBox=\"25 25 50 50\" tabindex=\"-1\"><circle cx=\"50\" cy=\"50\" r=\"20\"/></svg>',\n\n    // Main container element\n    main: null,\n  },\n\n  /* Note: If the `template.main` option is not provided, the structure is generated as follows by default:\n  <div class=\"fancybox__container\" role=\"dialog\" aria-modal=\"true\" aria-hidden=\"true\" aria-label=\"{{MODAL}}\" tabindex=\"-1\">\n    <div class=\"fancybox__backdrop\"></div>\n    <div class=\"fancybox__carousel\"></div>\n  </div>\n  */\n\n  // Localization of strings\n  l10n: {\n    CLOSE: \"Close\",\n    NEXT: \"Next\",\n    PREV: \"Previous\",\n    MODAL: \"You can close this modal content with the ESC key\",\n    ERROR: \"Something Went Wrong, Please Try Again Later\",\n    IMAGE_ERROR: \"Image Not Found\",\n    ELEMENT_NOT_FOUND: \"HTML Element Not Found\",\n    AJAX_NOT_FOUND: \"Error Loading AJAX : Not Found\",\n    AJAX_FORBIDDEN: \"Error Loading AJAX : Forbidden\",\n    IFRAME_ERROR: \"Error Loading Page\",\n  },\n};\n\nlet called = 0;\nlet preventScrollSupported = null;\n\nclass Fancybox extends _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_2__[\"Base\"] {\n  /**\n   * Fancybox constructor\n   * @constructs Fancybox\n   * @param {Object} [options] - Options for Fancybox\n   */\n  constructor(items, options = {}) {\n    const handleOptions = function (items, options) {\n      const firstOpts = Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(true, {}, items[options.startIndex] || {});\n\n      items.forEach((item) => {\n        const $trigger = item.$trigger;\n\n        if ($trigger) {\n          const dataset = $trigger.dataset || {};\n\n          item.src = dataset.src || $trigger.getAttribute(\"href\") || item.src;\n          item.type = dataset.type || item.type;\n        }\n      });\n\n      return Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(true, {}, Fancybox.defaults, options, firstOpts);\n    };\n\n    // Detect if .focus() method  supports `preventScroll` option,\n    // see https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/focus\n    preventScrollSupported = (function () {\n      let rez = false;\n\n      document.createElement(\"div\").focus({\n        get preventScroll() {\n          rez = true;\n          return false;\n        },\n      });\n\n      return rez;\n    })();\n\n    super(handleOptions(items, options));\n\n    this.state = \"init\";\n    this.items = items;\n\n    this.bindHandlers();\n\n    this.attachPlugins(Fancybox.Plugins);\n\n    this.trigger(\"init\");\n\n    if (this.option(\"hideScrollbar\") === true) {\n      this.hideScrollbar();\n    }\n\n    this.initLayout();\n\n    this.initCarousel(this.getSlides());\n\n    this.attachEvents();\n\n    this.state = \"ready\";\n\n    this.trigger(\"ready\");\n\n    // Reveal container\n    this.$container.setAttribute(\"aria-hidden\", \"false\");\n  }\n\n  /**\n   * Bind event handlers for referencability\n   */\n  bindHandlers() {\n    for (const methodName of [\n      \"onMousedown\",\n      \"onKeydown\",\n      \"onClick\",\n\n      \"onCreateSlide\",\n      \"onSettle\",\n\n      \"onTouchMove\",\n      \"onTouchEnd\",\n\n      \"onTransform\",\n    ]) {\n      this[methodName] = this[methodName].bind(this);\n    }\n  }\n\n  /**\n   * Set up a functions that will be called whenever the specified event is delivered\n   */\n  attachEvents() {\n    document.addEventListener(\"mousedown\", this.onMousedown);\n    document.addEventListener(\"keydown\", this.onKeydown);\n\n    this.$container.addEventListener(\"click\", this.onClick);\n  }\n\n  /**\n   * Removes previously registered event listeners\n   */\n  detachEvents() {\n    document.removeEventListener(\"mousedown\", this.onMousedown);\n    document.removeEventListener(\"keydown\", this.onKeydown);\n\n    this.$container.removeEventListener(\"click\", this.onClick);\n  }\n\n  /**\n   * Initialize layout; create main container, backdrop nd layout for main carousel\n   */\n  initLayout() {\n    this.$root = this.option(\"parentEl\") || document.body;\n\n    // Container\n    let mainTemplate = this.option(\"template.main\");\n\n    if (mainTemplate) {\n      this.$root.insertAdjacentHTML(\"beforeend\", this.localize(mainTemplate));\n\n      this.$container = this.$root.querySelector(\".fancybox__container\");\n    }\n\n    if (!this.$container) {\n      this.$container = document.createElement(\"div\");\n      this.$root.appendChild(this.$container);\n    }\n\n    // Normally we would not need this, but Safari does not support `preventScroll:false` option for `focus` method\n    // and that causes layout issues\n    this.$container.onscroll = () => {\n      this.$container.scrollLeft = 0;\n      return false;\n    };\n\n    Object.entries({\n      class: \"fancybox__container\",\n      role: \"dialog\",\n      \"aria-modal\": \"true\",\n      \"aria-hidden\": \"true\",\n      \"aria-label\": this.localize(\"{{MODAL}}\"),\n    }).forEach((args) => this.$container.setAttribute(...args));\n\n    if (this.option(\"animated\")) {\n      this.$container.classList.add(\"is-animated\");\n    }\n\n    // Backdrop\n    this.$backdrop = this.$container.querySelector(\".fancybox__backdrop\");\n\n    if (!this.$backdrop) {\n      this.$backdrop = document.createElement(\"div\");\n      this.$backdrop.classList.add(\"fancybox__backdrop\");\n\n      this.$container.appendChild(this.$backdrop);\n    }\n\n    // Carousel\n    this.$carousel = this.$container.querySelector(\".fancybox__carousel\");\n\n    if (!this.$carousel) {\n      this.$carousel = document.createElement(\"div\");\n      this.$carousel.classList.add(\"fancybox__carousel\");\n\n      this.$container.appendChild(this.$carousel);\n    }\n\n    // Make instance reference accessible\n    this.$container.Fancybox = this;\n\n    // Make sure the container has an ID\n    this.id = this.$container.getAttribute(\"id\");\n\n    if (!this.id) {\n      this.id = this.options.id || ++called;\n      this.$container.setAttribute(\"id\", \"fancybox-\" + this.id);\n    }\n\n    // Add custom class name to main element\n    const mainClass = this.options.mainClass;\n\n    if (mainClass) {\n      this.$container.classList.add(...mainClass.split(\" \"));\n    }\n\n    // Add class name for <html> element\n    document.documentElement.classList.add(\"with-fancybox\");\n\n    this.trigger(`initLayout`);\n\n    return this;\n  }\n\n  /**\n   * Gets and prepares slides (gets thumbnails) for the corousel\n   * @returns {Array} Slides\n   */\n  getSlides() {\n    const slides = [...this.items];\n\n    slides.forEach((slide) => {\n      // Support items without `src`, e.g., when `data-fancybox` attribute added directly to `<img>` element\n      if (!slide.src && slide.$trigger && slide.$trigger instanceof HTMLImageElement) {\n        slide.src = slide.$trigger.currentSrc || slide.$trigger.src;\n      }\n\n      // Check for thumbnail element\n      let $thumb = slide.$thumb;\n\n      const origTarget = slide.$trigger && slide.$trigger.origTarget;\n\n      if (origTarget) {\n        if (origTarget instanceof HTMLImageElement) {\n          $thumb = origTarget;\n        } else {\n          $thumb = origTarget.querySelector(\"img\");\n        }\n      }\n\n      if (!$thumb && slide.$trigger) {\n        $thumb = slide.$trigger instanceof HTMLImageElement ? slide.$trigger : slide.$trigger.querySelector(\"img\");\n      }\n\n      slide.$thumb = $thumb || null;\n\n      // Get thumbnail image source\n      let thumb = slide.thumb;\n\n      if (!thumb && slide.$thumb) {\n        thumb = $thumb.currentSrc || $thumb.src;\n      }\n\n      // Assume we have image, then use it as thumbnail\n      if (!thumb && (!slide.type || slide.type === \"image\")) {\n        thumb = slide.src;\n      }\n\n      slide.thumb = thumb || null;\n    });\n\n    return slides;\n  }\n\n  /**\n   * Initialize main Carousel that will be used to display the content\n   * @param {Array} slides\n   */\n  initCarousel(slides) {\n    new _Carousel_Carousel_js__WEBPACK_IMPORTED_MODULE_3__[\"Carousel\"](\n      this.$carousel,\n      Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(\n        true,\n        {},\n        {\n          classNames: {\n            viewport: \"fancybox__viewport\",\n            track: \"fancybox__track\",\n            slide: \"fancybox__slide\",\n          },\n\n          textSelection: true,\n          preload: this.option(\"preload\"),\n          friction: 0.88,\n\n          slides: slides,\n          initialPage: this.options.startIndex,\n          slidesPerPage: 1,\n\n          infiniteX: this.option(\"infinite\"),\n          infiniteY: true,\n\n          l10n: this.option(\"l10n\"),\n\n          Dots: false,\n          Navigation: {\n            classNames: {\n              main: \"fancybox__nav\",\n              button: \"carousel__button\",\n\n              next: \"is-next\",\n              prev: \"is-prev\",\n            },\n          },\n\n          Panzoom: {\n            panOnlyZoomed: () => {\n              return this.Carousel.pages.length < 2 && !this.options.dragToClose;\n            },\n            lockAxis: () => {\n              let rez = this.Carousel.pages.length > 1 ? \"x\" : \"\";\n\n              if (this.options.dragToClose) {\n                rez += \"y\";\n              }\n\n              return rez;\n            },\n          },\n\n          on: {\n            \"*\": (name, ...details) => this.trigger(`Carousel.${name}`, ...details),\n\n            init: (carousel) => (this.Carousel = carousel),\n\n            createSlide: this.onCreateSlide,\n            settle: this.onSettle,\n          },\n        },\n\n        this.option(\"Carousel\")\n      )\n    );\n\n    if (this.options.dragToClose) {\n      this.Carousel.Panzoom.on({\n        // Stop further touch event handling if content is scaled\n        touchMove: this.onTouchMove,\n\n        // Update backdrop opacity depending on vertical distance\n        afterTransform: this.onTransform,\n\n        // Close instance if drag distance exceeds limit\n        touchEnd: this.onTouchEnd,\n      });\n    }\n\n    this.trigger(`initCarousel`);\n\n    return this;\n  }\n\n  /**\n   * Process `createSlide` event to create caption element inside new slide\n   */\n  onCreateSlide(carousel, slide) {\n    const caption = slide.caption;\n\n    if (caption) {\n      const $caption = document.createElement(\"div\");\n      const id = `fancybox__caption_${this.id}_${slide.index}`;\n\n      $caption.className = \"fancybox__caption\";\n      $caption.innerHTML = caption;\n      $caption.setAttribute(\"id\", id);\n\n      slide.$caption = slide.$el.appendChild($caption);\n\n      slide.$el.classList.add(\"has-caption\");\n      slide.$el.setAttribute(\"aria-labelledby\", id);\n    }\n  }\n\n  /**\n   * Process `settle event to handle focus after animation has ended\n   */\n  onSettle() {\n    this.focus();\n  }\n\n  /**\n   * Handle click event on the container\n   * @param {Event} event - Click event\n   */\n  onClick(event) {\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    // Skip if clicked inside content area\n    if (event.target.closest(\".fancybox__content\")) {\n      return;\n    }\n\n    // Skip if text is selected\n    if (window.getSelection().toString().length) {\n      return;\n    }\n\n    const click = this.option(\"click\");\n\n    if (typeof click === \"function\") {\n      return click.call(this);\n    }\n\n    switch (click) {\n      case \"close\":\n        this.close();\n        break;\n      case \"next\":\n        this.next();\n        break;\n    }\n  }\n\n  /**\n   * Handle panzoom `touchMove` event; Disable dragging if content of current slide is scaled\n   */\n  onTouchMove() {\n    const panzoom = this.getSlide().Panzoom;\n\n    return panzoom && panzoom.current.scale !== 1 ? false : true;\n  }\n\n  /**\n   * Handle panzoom `touchEnd` event; close when quick flick up/down is detected\n   * @param {Object} panzoom - Panzoom instance\n   */\n  onTouchEnd(panzoom) {\n    const distanceY = panzoom.drag.distanceY;\n\n    if (Math.abs(distanceY) >= 150 || (Math.abs(distanceY) >= 35 && panzoom.drag.elapsedTime < 350)) {\n      if (this.option(\"hideClass\")) {\n        this.getSlide().hideClass = `fancybox-throwOut${panzoom.current.y < 0 ? \"Up\" : \"Down\"}`;\n      }\n\n      this.close();\n    }\n  }\n\n  /**\n   * Handle `afterTransform` event; change backdrop opacity based on current y position of panzoom\n   * @param {Object} panzoom - Panzoom instance\n   */\n  onTransform(panzoom) {\n    const $backdrop = this.$backdrop;\n\n    if ($backdrop) {\n      const yPos = Math.abs(panzoom.current.y);\n      const opacity = yPos < 1 ? \"\" : Math.max(0, Math.min(1, 1 - (yPos / panzoom.$content.clientHeight) * 1.5));\n\n      this.$container.style.setProperty(\"--fancybox-ts\", opacity ? \"0s\" : \"\");\n      this.$container.style.setProperty(\"--fancybox-opacity\", opacity);\n    }\n  }\n\n  /**\n   * Handle `mousedown` event to mark that the mouse is in use\n   */\n  onMousedown() {\n    document.body.classList.add(\"is-using-mouse\");\n  }\n\n  /**\n   * Handle `keydown` event; trap focus\n   * @param {Event} event Keydown event\n   */\n  onKeydown(event) {\n    if (Fancybox.getInstance().id !== this.id) {\n      return;\n    }\n\n    document.body.classList.remove(\"is-using-mouse\");\n\n    const key = event.key;\n\n    // Trap keyboard focus inside of the modal\n    if (key === \"Tab\" && this.option(\"trapFocus\")) {\n      this.focus(event);\n\n      return;\n    }\n\n    const keyboard = this.option(\"keyboard\");\n\n    if (!keyboard || event.ctrlKey || event.altKey || event.shiftKey) {\n      return;\n    }\n\n    const classList = document.activeElement && document.activeElement.classList;\n    const isUIElement = classList && classList.contains(\"carousel__button\");\n\n    // Allow to close using Escape button\n    if (key !== \"Escape\" && !isUIElement) {\n      let ignoreElements =\n        event.target.isContentEditable ||\n        [\"BUTTON\", \"TEXTAREA\", \"OPTION\", \"INPUT\", \"SELECT\", \"VIDEO\"].indexOf(event.target.nodeName) !== -1;\n\n      if (ignoreElements) {\n        return;\n      }\n    }\n\n    if (this.trigger(\"keydown\", key) === false) {\n      return;\n    }\n\n    if (key !== \"Enter\") {\n      event.preventDefault();\n    }\n\n    const action = keyboard[key];\n\n    if (typeof this[action] === \"function\") {\n      this[action]();\n    }\n  }\n\n  /**\n   * Get the active slide. This will be the first slide from the current page of the main carousel.\n   */\n  getSlide() {\n    const carousel = this.Carousel;\n\n    if (!carousel) return null;\n\n    const page = carousel.page === null ? carousel.option(\"initialPage\") : carousel.page;\n    const pages = carousel.pages || [];\n\n    if (pages.length && pages[page]) {\n      return pages[page].slides[0];\n    }\n\n    return null;\n  }\n\n  /**\n   * Place focus on the first focusable element inside current slide\n   * @param {Event} [event] - Focus event\n   */\n  focus(event) {\n    const setFocusOn = (node) => {\n      if (node.setActive) {\n        // IE/Edge\n        node.setActive();\n      } else if (preventScrollSupported) {\n        // Modern browsers\n        node.focus({ preventScroll: true });\n      } else {\n        // Safari\n        node.focus();\n      }\n    };\n\n    if (event) {\n      event.preventDefault();\n    }\n\n    const FOCUSABLE_ELEMENTS = [\n      \"a[href]\",\n      \"area[href]\",\n      'input:not([disabled]):not([type=\"hidden\"]):not([aria-hidden])',\n      \"select:not([disabled]):not([aria-hidden])\",\n      \"textarea:not([disabled]):not([aria-hidden])\",\n      \"button:not([disabled]):not([aria-hidden])\",\n      \"iframe\",\n      \"object\",\n      \"embed\",\n      \"video\",\n      \"audio\",\n      \"[contenteditable]\",\n      '[tabindex]:not([tabindex^=\"-\"]):not([disabled]):not([aria-hidden])',\n    ];\n\n    const $currentSlide = this.getSlide().$el;\n\n    // Setting `tabIndex` here helps to avoid Safari issues with random focusing and scrolling\n    $currentSlide.tabIndex = 0;\n\n    const allFocusableElems = [].slice.call(this.$container.querySelectorAll(FOCUSABLE_ELEMENTS));\n    const enabledElems = [];\n\n    for (let node of allFocusableElems) {\n      // Slide element will be the last one, the highest priority has elements having `autofocus` attribute\n      if (node.classList && node.classList.contains(\"fancybox__slide\")) {\n        continue;\n      }\n\n      const $closestSlide = node.closest(\".fancybox__slide\");\n\n      if ($closestSlide) {\n        if ($closestSlide === $currentSlide) {\n          enabledElems[node.hasAttribute(\"autofocus\") ? \"unshift\" : \"push\"](node);\n        }\n      } else {\n        enabledElems.push(node);\n      }\n    }\n\n    if (!enabledElems.length) {\n      return;\n    }\n\n    if (this.Carousel.pages.length > 1) {\n      enabledElems.push($currentSlide);\n    }\n\n    const focusedElementIndex = enabledElems.indexOf(document.activeElement);\n\n    const moveForward = event && !event.shiftKey;\n    const moveBackward = event && event.shiftKey;\n\n    if (moveForward) {\n      if (focusedElementIndex === enabledElems.length - 1) {\n        return setFocusOn(enabledElems[0]);\n      }\n\n      return setFocusOn(enabledElems[focusedElementIndex + 1]);\n    }\n\n    if (moveBackward) {\n      if (focusedElementIndex === 0) {\n        return setFocusOn(enabledElems[enabledElems.length - 1]);\n      }\n\n      return setFocusOn(enabledElems[focusedElementIndex - 1]);\n    }\n\n    if (focusedElementIndex < 0) {\n      return setFocusOn(enabledElems[0]);\n    }\n  }\n\n  /**\n   * Hide vertical page scrollbar and adjust right padding value of `body` element to prevent content from shifting\n   * (otherwise the `body` element may become wider and the content may expand horizontally).\n   */\n  hideScrollbar() {\n    if (!_shared_utils_canUseDOM_js__WEBPACK_IMPORTED_MODULE_1__[\"canUseDOM\"]) {\n      return;\n    }\n\n    const scrollbarWidth = window.innerWidth - document.documentElement.getBoundingClientRect().width;\n    const id = \"fancybox-style-noscroll\";\n\n    let $style = document.getElementById(id);\n\n    if ($style) {\n      return;\n    }\n\n    if (scrollbarWidth) {\n      $style = document.createElement(\"style\");\n\n      $style.id = id;\n      $style.type = \"text/css\";\n      $style.innerHTML = `.compensate-for-scrollbar {padding-right: ${scrollbarWidth}px;}`;\n\n      document.getElementsByTagName(\"head\")[0].appendChild($style);\n\n      document.body.classList.add(\"compensate-for-scrollbar\");\n    }\n  }\n\n  /**\n   * Stop hiding vertical page scrollbar\n   */\n  revealScrollbar() {\n    document.body.classList.remove(\"compensate-for-scrollbar\");\n\n    const el = document.getElementById(\"fancybox-style-noscroll\");\n\n    if (el) {\n      el.remove();\n    }\n  }\n\n  /**\n   * Remove content for given slide\n   * @param {Object} slide - Carousel slide\n   */\n  clearContent(slide) {\n    // * Clear previously added content and class name\n    this.Carousel.trigger(\"deleteSlide\", slide);\n\n    if (slide.$content) {\n      slide.$content.remove();\n      slide.$content = null;\n    }\n\n    if (slide._className) {\n      slide.$el.classList.remove(slide._className);\n    }\n  }\n\n  /**\n   * Set new content for given slide\n   * @param {Object} slide - Carousel slide\n   * @param {HTMLElement|String} html - HTML element or string containing HTML code\n   * @param {Object} [opts] - Options\n   */\n  setContent(slide, html, opts = {}) {\n    let $content;\n\n    const $el = slide.$el;\n\n    if (html instanceof HTMLElement) {\n      if ([\"img\", \"iframe\", \"video\", \"audio\"].indexOf(html.nodeName.toLowerCase()) > -1) {\n        $content = document.createElement(\"div\");\n        $content.appendChild(html);\n      } else {\n        $content = html;\n      }\n    } else {\n      $content = document.createElement(\"div\");\n      $content.innerHTML = html;\n    }\n\n    if (!($content instanceof Element)) {\n      throw new Error(\"Element expected\");\n    }\n\n    // * Add class name indicating content type, for example `has-image`\n    slide._className = `has-${opts.suffix || slide.type || \"unknown\"}`;\n\n    $el.classList.add(slide._className);\n\n    // * Set content\n    $content.classList.add(\"fancybox__content\");\n\n    // Make sure that content is not hidden and will be visible\n    if ($content.style.display === \"none\" || window.getComputedStyle($content).getPropertyValue(\"display\") === \"none\") {\n      $content.style.display = \"flex\";\n    }\n\n    if (slide.id) {\n      $content.setAttribute(\"id\", slide.id);\n    }\n\n    slide.$content = $content;\n\n    $el.insertBefore($content, $el.querySelector(\".fancybox__caption\"));\n\n    this.manageCloseButton(slide);\n\n    if (slide.state !== \"loading\") {\n      this.revealContent(slide);\n    }\n\n    return $content;\n  }\n\n  /**\n   * Create close button if needed\n   * @param {Object} slide\n   */\n  manageCloseButton(slide) {\n    const position = slide.closeButton === undefined ? this.option(\"closeButton\") : slide.closeButton;\n\n    if (!position || (this.$closeButton && position !== \"inside\")) {\n      return;\n    }\n\n    const $btn = document.createElement(\"button\");\n\n    $btn.classList.add(\"carousel__button\", \"is-close\");\n    $btn.setAttribute(\"title\", this.options.l10n.CLOSE);\n    $btn.innerHTML = this.option(\"template.closeButton\");\n\n    $btn.addEventListener(\"click\", (e) => this.close(e));\n\n    if (position === \"inside\") {\n      // Remove existing one to avoid scope issues\n      if (slide.$closeButton) {\n        slide.$closeButton.remove();\n      }\n\n      slide.$closeButton = slide.$content.appendChild($btn);\n    } else {\n      this.$closeButton = this.$container.insertBefore($btn, this.$container.firstChild);\n    }\n  }\n\n  /**\n   * Make content visible for given slide and optionally start CSS animation\n   * @param {Object} slide - Carousel slide\n   */\n  revealContent(slide) {\n    this.trigger(\"reveal\", slide);\n\n    slide.$content.style.visibility = \"\";\n\n    // Add CSS class name that reveals content (default animation is \"fadeIn\")\n    let showClass = false;\n\n    if (\n      !(\n        slide.state === \"error\" ||\n        slide.state === \"ready\" ||\n        this.Carousel.prevPage !== null ||\n        slide.index !== this.options.startIndex\n      )\n    ) {\n      showClass = slide.showClass === undefined ? this.option(\"showClass\") : slide.showClass;\n    }\n\n    if (!showClass) {\n      this.done(slide);\n\n      return;\n    }\n\n    slide.state = \"animating\";\n\n    this.animateCSS(slide.$content, showClass, () => {\n      this.done(slide);\n    });\n  }\n\n  /**\n   * Add class name to given HTML element and wait for `animationend` event to execute callback\n   * @param {HTMLElement} $el\n   * @param {String} className\n   * @param {Function} callback - A callback to run\n   */\n  animateCSS($element, className, callback) {\n    if ($element) {\n      $element.dispatchEvent(new CustomEvent(\"animationend\", { bubbles: true, cancelable: true }));\n    }\n\n    if (!$element || !className) {\n      if (typeof callback === \"function\") {\n        callback();\n      }\n\n      return;\n    }\n\n    const handleAnimationEnd = function (event) {\n      if (event.currentTarget === this) {\n        $element.classList.remove(className);\n\n        $element.removeEventListener(\"animationend\", handleAnimationEnd);\n\n        if (callback) {\n          callback();\n        }\n      }\n    };\n\n    $element.addEventListener(\"animationend\", handleAnimationEnd);\n    $element.classList.add(className);\n  }\n\n  /**\n   * Mark given slide as `done`, e.g., content is loaded and displayed completely\n   * @param {Object} slide - Carousel slide\n   */\n  done(slide) {\n    if (!(this.state === \"init\" || this.state === \"ready\")) {\n      return;\n    }\n\n    slide.state = \"done\";\n\n    this.trigger(\"done\", slide);\n\n    // Trigger focus for current slide (and ignore preloaded slides)\n    const currentSlide = this.getSlide();\n\n    if (currentSlide && slide.index === currentSlide.index && this.option(\"autoFocus\")) {\n      this.focus();\n    }\n  }\n\n  /**\n   * Set error message as slide content\n   * @param {Object} slide - Carousel slide\n   * @param {String} message - Error message, can contain HTML code and template variables\n   */\n  setError(slide, message) {\n    slide.state = \"error\";\n\n    this.hideLoading(slide);\n    this.clearContent(slide);\n\n    // Create new content\n    const div = document.createElement(`div`);\n    div.classList.add(`fancybox-error`);\n    div.innerHTML = this.localize(message || \"<p>{{ERROR}}</p>\");\n\n    this.setContent(slide, div, { suffix: \"error\" });\n  }\n\n  /**\n   * Create loading indicator inside given slide\n   * @param {Object} slide - Carousel slide\n   */\n  showLoading(slide) {\n    slide.state = \"loading\";\n\n    this.trigger(\"load\", slide);\n\n    slide.$el.classList.add(\"is-loading\");\n\n    let $spinner = slide.$el.querySelector(\".fancybox__spinner\");\n\n    if ($spinner) {\n      return;\n    }\n\n    $spinner = document.createElement(\"div\");\n\n    $spinner.classList.add(\"fancybox__spinner\");\n    $spinner.innerHTML = this.option(\"template.spinner\");\n\n    $spinner.addEventListener(\"click\", () => {\n      if (!this.Carousel.Panzoom.velocity) this.close();\n    });\n\n    slide.$el.insertBefore($spinner, slide.$el.firstChild);\n  }\n\n  /**\n   * Remove loading indicator from given slide\n   * @param {Object} slide - Carousel slide\n   */\n  hideLoading(slide) {\n    const $spinner = slide.$el && slide.$el.querySelector(\".fancybox__spinner\");\n\n    if ($spinner) {\n      $spinner.remove();\n\n      slide.$el.classList.remove(\"is-loading\");\n    }\n\n    if (slide.state === \"loading\") {\n      slide.state = \"ready\";\n    }\n  }\n\n  /**\n   * Slide carousel to next page\n   */\n  next() {\n    const carousel = this.Carousel;\n\n    if (carousel && carousel.pages.length > 1) {\n      carousel.slideNext();\n    }\n  }\n\n  /**\n   * Slide carousel to previous page\n   */\n  prev() {\n    const carousel = this.Carousel;\n\n    if (carousel && carousel.pages.length > 1) {\n      carousel.slidePrev();\n    }\n  }\n\n  /**\n   * Slide carousel to selected page with optional parameters\n   * Examples:\n   *    Fancybox.getInstance().jumpTo(2);\n   *    Fancybox.getInstance().jumpTo(3, {friction: 0})\n   * @param  {...any} args - Arguments for Carousel `slideTo` method\n   */\n  jumpTo(...args) {\n    if (this.Carousel) this.Carousel.slideTo(...args);\n  }\n\n  /**\n   * Start closing the current instance\n   * @param {Event} [event] - Optional click event\n   */\n  close(event) {\n    if (event) event.preventDefault();\n\n    // First, stop further execution if this instance is already closing\n    // (this can happen if, for example, user clicks close button multiple times really fast)\n    if ([\"closing\", \"customClosing\", \"destroy\"].indexOf(this.state) > -1) {\n      return;\n    }\n\n    // Allow callbacks and/or plugins to prevent closing\n    if (this.trigger(\"shouldClose\", event) === false) {\n      return;\n    }\n\n    this.state = \"closing\";\n\n    this.Carousel.Panzoom.destroy();\n\n    this.detachEvents();\n\n    this.trigger(\"closing\", event);\n\n    if (this.state === \"destroy\") {\n      return;\n    }\n\n    this.$container.setAttribute(\"aria-hidden\", \"true\");\n\n    this.$container.classList.add(\"is-closing\");\n\n    // Clear inactive slides\n    const currentSlide = this.getSlide();\n\n    this.Carousel.slides.forEach((slide) => {\n      if (slide.$content && slide.index !== currentSlide.index) {\n        slide.$content.remove();\n      }\n    });\n\n    // Start default closing animation\n    if (this.state === \"closing\") {\n      const hideClass = currentSlide.hideClass === undefined ? this.option(\"hideClass\") : currentSlide.hideClass;\n\n      this.animateCSS(currentSlide.$content, hideClass, () => {\n        this.destroy();\n      });\n    }\n  }\n\n  /**\n   * Clean up after closing fancybox\n   */\n  destroy() {\n    this.state = \"destroy\";\n\n    this.trigger(\"destroy\");\n\n    const $trigger = this.option(\"placeFocusBack\") ? this.getSlide().$trigger : null;\n\n    // Destroy Carousel and then detach plugins;\n    // * Note: this order allows plugins to receive `deleteSlide` event\n    this.Carousel.destroy();\n\n    this.detachPlugins();\n\n    this.Carousel = null;\n\n    this.options = {};\n    this.events = {};\n\n    this.$container.remove();\n\n    this.$container = this.$backdrop = this.$carousel = null;\n\n    if ($trigger) {\n      // `preventScroll` option is not yet supported by Safari\n      // https://bugs.webkit.org/show_bug.cgi?id=178583\n\n      if (preventScrollSupported) {\n        $trigger.focus({ preventScroll: true });\n      } else {\n        const scrollTop = document.body.scrollTop; // Save position\n        $trigger.focus();\n        document.body.scrollTop = scrollTop;\n      }\n    }\n\n    const nextInstance = Fancybox.getInstance();\n\n    if (nextInstance) {\n      nextInstance.focus();\n      return;\n    }\n\n    document.documentElement.classList.remove(\"with-fancybox\");\n    document.body.classList.remove(\"is-using-mouse\");\n\n    this.revealScrollbar();\n  }\n\n  /**\n   * Create new Fancybox instance with provided options\n   * Example:\n   *   Fancybox.show([{ src : 'https://lipsum.app/id/1/300x225' }]);\n   * @param {Array} items - Gallery items\n   * @param {Object} [options] - Optional custom options\n   * @returns {Object} Fancybox instance\n   */\n  static show(items, options = {}) {\n    return new Fancybox(items, options);\n  }\n\n  /**\n   * Starts Fancybox if event target matches any opener or target is `trigger element`\n   * @param {Event} event - Click event\n   * @param {Object} [options] - Optional custom options\n   */\n  static fromEvent(event, options = {}) {\n    //  Allow other scripts to prevent starting fancybox on click\n    if (event.defaultPrevented) return;\n\n    // Don't run if right-click\n    if (event.button && event.button !== 0) return;\n\n    // Ignore command/control + click\n    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n      return;\n    }\n\n    let rez = false;\n    let target;\n    let found;\n\n    let eventTarget = event.target;\n\n    let triggerGroupName;\n\n    if (\n      eventTarget.matches(\"[data-fancybox-trigger]\") ||\n      (eventTarget = eventTarget.closest(\"[data-fancybox-trigger]\"))\n    ) {\n      triggerGroupName = eventTarget && eventTarget.dataset && eventTarget.dataset.fancyboxTrigger;\n    }\n\n    if (triggerGroupName) {\n      const triggerItems = document.querySelectorAll(`[data-fancybox=\"${triggerGroupName}\"]`);\n      const triggerIndex = parseInt(eventTarget.dataset.fancyboxIndex, 10) || 0;\n\n      eventTarget = triggerItems.length ? triggerItems[triggerIndex] : eventTarget;\n    }\n\n    if (!eventTarget) {\n      eventTarget = event.target;\n    }\n\n    // * Try to find matching openener\n    Array.from(Fancybox.openers.keys())\n      .reverse()\n      .some((opener) => {\n        target = eventTarget;\n\n        // Chain closest() to event.target to find and return the parent element,\n        // regardless if clicking on the child elements (icon, label, etc)\n        if (!(target.matches(opener) || (target = target.closest(opener)))) {\n          return;\n        }\n\n        event.preventDefault();\n\n        found = opener;\n\n        return true;\n      });\n\n    if (found) {\n      options.target = target;\n      target.origTarget = event.target;\n\n      rez = Fancybox.fromOpener(found, options);\n    }\n\n    // Check if the mouse is being used\n    // Waiting for better browser support for `:focus-visible` -\n    // https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo\n    const nextInstance = Fancybox.getInstance();\n\n    if (nextInstance && nextInstance.state === \"ready\" && event.detail) {\n      document.body.classList.add(\"is-using-mouse\");\n    }\n\n    return rez;\n  }\n\n  /**\n   * Starts Fancybox using selector\n   * @param {String} opener - Valid CSS selector string\n   * @param {Object} [options] - Optional custom options\n   */\n  static fromOpener(opener, options = {}) {\n    // Callback function called once for each group element that\n    // 1) converts data attributes to boolean or JSON\n    // 2) removes values that could cause issues\n    const mapCallback = function (el) {\n      const falseValues = [\"false\", \"0\", \"no\", \"null\"];\n      const trueValues = [\"true\", \"1\", \"yes\"];\n\n      const options = Object.assign({}, el.dataset);\n\n      for (let [key, value] of Object.entries(options)) {\n        if (typeof value === \"string\" || value instanceof String) {\n          if (falseValues.indexOf(value) > -1) {\n            options[key] = false;\n          } else if (trueValues.indexOf(options[key]) > -1) {\n            options[key] = true;\n          } else {\n            try {\n              options[key] = JSON.parse(value);\n            } catch (e) {\n              options[key] = value;\n            }\n          }\n        }\n      }\n\n      delete options.fancybox;\n      delete options.type;\n\n      if (el instanceof Element) {\n        options.$trigger = el;\n      }\n\n      return options;\n    };\n\n    let items = [],\n      index = options.startIndex || 0;\n\n    // Get options\n    options = Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])({}, options, Fancybox.openers.get(opener));\n\n    // Check what data attribute is used to indicate group items\n    let groupAttr = options.groupAttr;\n\n    if (groupAttr === undefined) {\n      groupAttr = \"data-fancybox\";\n    }\n\n    let target = options.target;\n\n    if (groupAttr) {\n      if (target && opener && opener === `[${groupAttr}]`) {\n        const groupValue = target.getAttribute(`${groupAttr}`);\n\n        if (groupValue && groupValue.length && groupValue !== \"true\") {\n          opener = `[${groupAttr}='${groupValue}']`;\n        } else {\n          // If this is empty value, then do not group items\n          opener = false;\n        }\n      }\n    } else {\n      opener = false;\n    }\n\n    // Get matching nodes\n    if (opener) {\n      items = [].slice.call(document.querySelectorAll(opener));\n    }\n\n    if (!items.length && target) {\n      items = [target];\n    }\n\n    if (!items.length) {\n      return false;\n    }\n\n    // Exit if current instance is triggered from the same element\n    const currentInstance = Fancybox.getInstance();\n\n    if (currentInstance && items.indexOf(currentInstance.options.$trigger) > -1) {\n      return false;\n    }\n\n    // Index of current item in the gallery\n    index = target ? items.indexOf(target) : index;\n\n    // Convert items in a format supported by fancybox\n    items = items.map(mapCallback);\n\n    // * Create new fancybox instance\n    return new Fancybox(\n      items,\n      Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])({}, options, {\n        startIndex: index,\n        $trigger: target,\n      })\n    );\n  }\n\n  /**\n   * Attach a click handler function that starts Fancybox to the selected items, as well as to all future matching elements.\n   * @param {String} selector - Selector that should match trigger elements\n   * @param {Object} [options] - Custom options\n   */\n  static bind(selector, options = {}) {\n    if (!_shared_utils_canUseDOM_js__WEBPACK_IMPORTED_MODULE_1__[\"canUseDOM\"]) {\n      return;\n    }\n\n    if (!Fancybox.openers.size) {\n      document.body.addEventListener(\"click\", Fancybox.fromEvent, false);\n\n      // Pass self to plugins to avoid circular dependencies\n      for (const [key, Plugin] of Object.entries(Fancybox.Plugins || {})) {\n        Plugin.Fancybox = this;\n\n        if (typeof Plugin.create === \"function\") {\n          Plugin.create();\n        }\n      }\n    }\n\n    Fancybox.openers.set(selector, options);\n  }\n\n  /**\n   * Remove the click handler that was attached with `bind()`\n   * @param {String} selector - A selector which should match the one originally passed to .bind()\n   */\n  static unbind(selector) {\n    Fancybox.openers.delete(selector);\n\n    if (!Fancybox.openers.size) {\n      Fancybox.destroy();\n    }\n  }\n\n  /**\n   * Immediately destroy all instances (without closing animation) and clean up all bindings..\n   */\n  static destroy() {\n    let fb;\n\n    while ((fb = Fancybox.getInstance())) {\n      fb.destroy();\n    }\n\n    Fancybox.openers = new Map();\n\n    document.body.removeEventListener(\"click\", Fancybox.fromEvent, false);\n  }\n\n  /**\n   * Retrieve instance by identifier or the top most instance, if identifier is not provided\n   * @param {String|Numeric} [id] - Optional instance identifier\n   */\n  static getInstance(id) {\n    let nodes = [];\n\n    if (id) {\n      nodes = [document.getElementById(`fancybox-${id}`)];\n    } else {\n      nodes = Array.from(document.querySelectorAll(\".fancybox__container\")).reverse();\n    }\n\n    for (const $container of nodes) {\n      const instance = $container && $container.Fancybox;\n\n      if (instance && instance.state !== \"closing\" && instance.state !== \"customClosing\") {\n        return instance;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Close all or topmost currently active instance.\n   * @param {boolean} [all] - All or only topmost active instance\n   */\n  static close(all = true) {\n    let instance = null;\n\n    while ((instance = Fancybox.getInstance())) {\n      instance.close();\n\n      if (!all) return;\n    }\n  }\n}\n\n// Expose version\nFancybox.version = \"__VERSION__\";\n\n// Expose defaults\nFancybox.defaults = defaults;\n\n// Expose openers\nFancybox.openers = new Map();\n\n// Add default plugins\nFancybox.Plugins = _plugins_index_js__WEBPACK_IMPORTED_MODULE_4__[\"Plugins\"];\n\n// Detect mobile device\nFancybox.isMobile = () =>\n  navigator ? /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) : false;\n\n// Auto init with default options\nFancybox.bind(\"[data-fancybox]\");\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Fancybox/Fancybox.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Hash/Hash.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/Hash/Hash.js ***!
  \**********************************************************************/
/*! exports provided: Hash */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Hash\", function() { return Hash; });\n/* harmony import */ var _shared_utils_canUseDOM_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/utils/canUseDOM.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/canUseDOM.js\");\n\n\n/**\n * Helper method to split URL hash into useful pieces\n */\nconst getParsedURL = function () {\n  const hash = window.location.hash.substr(1),\n    tmp = hash.split(\"-\"),\n    index = tmp.length > 1 && /^\\+?\\d+$/.test(tmp[tmp.length - 1]) ? parseInt(tmp.pop(-1), 10) || null : null,\n    slug = tmp.join(\"-\");\n\n  return {\n    hash,\n    slug,\n    index,\n  };\n};\n\nclass Hash {\n  constructor(fancybox) {\n    this.fancybox = fancybox;\n\n    this.events = {\n      closing: this.onClosing.bind(this),\n      \"Carousel.ready Carousel.change\": this.onChange.bind(this),\n    };\n\n    this.hasCreatedHistory = false;\n    this.origHash = \"\";\n    this.timer = null;\n  }\n\n  /**\n   * Process `Carousel.ready` and `Carousel.change` events to update URL hash\n   * @param {Object} fancybox\n   * @param {Object} carousel\n   */\n  onChange(fancybox, carousel) {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n\n    const firstRun = carousel.prevPage === null;\n\n    const slide = fancybox.getSlide();\n    const dataset = slide.$trigger && slide.$trigger.dataset;\n\n    const currentHash = window.location.hash.substr(1);\n\n    let newHash = false;\n\n    if (slide.slug) {\n      newHash = slide.slug;\n    } else {\n      let dataAttribute = dataset && dataset.fancybox;\n\n      if (dataAttribute && dataAttribute.length && dataAttribute !== \"true\") {\n        newHash = dataAttribute + (carousel.slides.length > 1 ? \"-\" + (slide.index + 1) : \"\");\n      }\n    }\n\n    if (firstRun) {\n      this.origHash = currentHash !== newHash ? this.origHash : \"\";\n    }\n\n    if (newHash && currentHash !== newHash) {\n      this.timer = setTimeout(() => {\n        try {\n          window.history[firstRun ? \"pushState\" : \"replaceState\"](\n            {},\n            document.title,\n            window.location.pathname + window.location.search + \"#\" + newHash\n          );\n\n          if (firstRun) {\n            this.hasCreatedHistory = true;\n          }\n        } catch (e) {}\n      }, 300);\n    }\n  }\n\n  /**\n   * Process `closing` event to clean up\n   */\n  onClosing() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n\n    // Skip if closing is triggered by pressing  browser back button or by changing hash manually\n    if (this.hasSilentClose === true) {\n      return;\n    }\n\n    // Simply make browser to move back one page in the session history,\n    // if new history entry is successfully created\n    if (!this.hasCreatedHistory) {\n      try {\n        window.history.replaceState(\n          {},\n          document.title,\n          window.location.pathname + window.location.search + (this.origHash ? \"#\" + this.origHash : \"\")\n        );\n\n        return;\n      } catch (e) {}\n    }\n\n    window.history.back();\n  }\n\n  attach(fancybox) {\n    fancybox.on(this.events);\n  }\n\n  detach(fancybox) {\n    fancybox.off(this.events);\n  }\n\n  /**\n   * Start fancybox from current URL hash,\n   * this will be called on page load OR/AND after changing URL hash\n   * @param {Class} Fancybox\n   */\n  static startFromUrl() {\n    if (Hash.Fancybox.getInstance()) {\n      return;\n    }\n\n    const { hash, slug, index } = getParsedURL();\n\n    if (!slug) {\n      return;\n    }\n\n    // Support custom slug\n    let selectedElem = document.querySelector(`[data-slug=\"${hash}\"]`);\n\n    if (selectedElem) {\n      selectedElem.dispatchEvent(new CustomEvent(\"click\", { bubbles: true, cancelable: true }));\n    }\n\n    if (Hash.Fancybox.getInstance()) {\n      return;\n    }\n\n    // Use URL hash value as group name\n    const groupElems = document.querySelectorAll(`[data-fancybox=\"${slug}\"]`);\n\n    if (!groupElems.length) {\n      return;\n    }\n\n    if (index === null && groupElems.length === 1) {\n      selectedElem = groupElems[0];\n    } else if (index) {\n      selectedElem = groupElems[index - 1];\n    }\n\n    if (selectedElem) {\n      selectedElem.dispatchEvent(new CustomEvent(\"click\", { bubbles: true, cancelable: true }));\n    }\n  }\n\n  /**\n   * Handle `hash` change, change gallery item to current index or start/close current instance\n   */\n  static onHashChange() {\n    const { slug, index } = getParsedURL();\n\n    const instance = Hash.Fancybox.getInstance();\n\n    if (instance) {\n      // Look if this is inside currently active gallery\n      if (slug) {\n        const carousel = instance.Carousel;\n        /**\n         * Check if URL hash matches `data-slug` value of active element\n         */\n        for (let slide of carousel.slides) {\n          if (slide.slug && slide.slug === slug) {\n            return carousel.slideTo(slide.index);\n          }\n        }\n\n        /**\n         * Check if URL hash matches `data-fancybox` value of active element\n         */\n        const slide = instance.getSlide();\n        const dataset = slide.$trigger && slide.$trigger.dataset;\n\n        if (dataset && dataset.fancybox === slug) {\n          return carousel.slideTo(index - 1);\n        }\n      }\n\n      /**\n       * Close if no matching element found\n       */\n      instance.plugins.Hash.hasSilentClose = true;\n\n      instance.close();\n    }\n\n    /**\n     * Attempt to start\n     */\n\n    Hash.startFromUrl();\n  }\n\n  /**\n   * Add event bindings that will start new Fancybox instance based in the current URL\n   */\n\n  static onReady() {\n    window.addEventListener(\"hashchange\", Hash.onHashChange, false);\n\n    Hash.startFromUrl();\n  }\n\n  static create() {\n    // Skip if SSR\n    if (!_shared_utils_canUseDOM_js__WEBPACK_IMPORTED_MODULE_0__[\"canUseDOM\"]) {\n      return;\n    }\n\n    /**\n     * Wait for document to be been completely loaded and parsed to attempt to start Fancybox\n     */\n\n    window.requestAnimationFrame(() => {\n      Hash.onReady();\n    });\n  }\n\n  static destroy() {\n    window.removeEventListener(\"hashchange\", Hash.onHashChange, false);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Fancybox/plugins/Hash/Hash.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Html/Html.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/Html/Html.js ***!
  \**********************************************************************/
/*! exports provided: Html */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Html\", function() { return Html; });\n/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/utils/extend.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/extend.js\");\n\n\nconst buildURLQuery = (obj) => {\n  return Object.entries(obj)\n    .map((pair) => pair.map(encodeURIComponent).join(\"=\"))\n    .join(\"&\");\n};\n\nconst defaults = {\n  // General options for any video content (Youtube, Vimeo, HTML5 video)\n  video: {\n    autoplay: true,\n    ratio: 16 / 9,\n  },\n  // Youtube embed parameters\n  youtube: {\n    autohide: 1,\n    fs: 1,\n    rel: 0,\n    hd: 1,\n    wmode: \"transparent\",\n    enablejsapi: 1,\n    html5: 1,\n  },\n  // Vimeo embed parameters\n  vimeo: {\n    hd: 1,\n    show_title: 1,\n    show_byline: 1,\n    show_portrait: 0,\n    fullscreen: 1,\n  },\n  // HTML5 video parameters\n  html5video: {\n    tpl: `<video class=\"fancybox__html5video\" playsinline controls controlsList=\"nodownload\" poster=\"{{poster}}\">\n  <source src=\"{{src}}\" type=\"{{format}}\" />\n  Sorry, your browser doesn\\'t support embedded videos, <a href=\"{{src}}\">download</a> and watch with your favorite video player!\n</video>`,\n    format: \"\",\n  },\n};\n\nclass Html {\n  constructor(fancybox) {\n    this.fancybox = fancybox;\n\n    for (const methodName of [\n      \"onPrepare\",\n\n      \"onCreateSlide\",\n      \"onDeleteSlide\",\n\n      \"onSelectSlide\",\n      \"onUnselectSlide\",\n\n      \"onRefresh\",\n\n      // For communication with iframed video (youtube/vimeo)\n      \"onMessage\",\n    ]) {\n      this[methodName] = this[methodName].bind(this);\n    }\n\n    this.events = {\n      init: this.onPrepare,\n\n      \"Carousel.createSlide\": this.onCreateSlide,\n      \"Carousel.deleteSlide\": this.onDeleteSlide,\n\n      \"Carousel.selectSlide\": this.onSelectSlide,\n      \"Carousel.unselectSlide\": this.onUnselectSlide,\n\n      \"Carousel.refresh\": this.onRefresh,\n    };\n  }\n\n  /**\n   * Check if each gallery item has type when fancybox starts\n   */\n  onPrepare() {\n    this.fancybox.items.forEach((slide) => {\n      this.processType(slide);\n    });\n  }\n\n  /**\n   * Set content type for the slide\n   * @param {Object} slide\n   */\n  processType(slide) {\n    // Add support for `new Fancybox({items : [{html : 'smth'}]});`\n    if (slide.html) {\n      slide.src = slide.html;\n      slide.type = \"html\";\n\n      delete slide.html;\n\n      return;\n    }\n\n    const src = slide.src || \"\";\n    let type = slide.type || this.fancybox.options.type,\n      rez = null;\n\n    if (src && typeof src !== \"string\") {\n      return;\n    }\n\n    if (\n      (rez = src.match(\n        /(?:youtube\\.com|youtu\\.be|youtube\\-nocookie\\.com)\\/(?:watch\\?(?:.*&)?v=|v\\/|u\\/|embed\\/?)?(videoseries\\?list=(?:.*)|[\\w-]{11}|\\?listType=(?:.*)&list=(?:.*))(?:.*)/i\n      ))\n    ) {\n      const params = buildURLQuery(this.fancybox.option(\"Html.youtube\"));\n      const videoId = encodeURIComponent(rez[1]);\n\n      slide.videoId = videoId;\n      slide.src = `https://www.youtube-nocookie.com/embed/${videoId}?${params}`;\n      slide.thumb = slide.thumb || `https://i.ytimg.com/vi/${videoId}/mqdefault.jpg`;\n      slide.vendor = \"youtube\";\n\n      type = \"video\";\n    } else if ((rez = src.match(/^.+vimeo.com\\/(?:\\/)?([\\d]+)(.*)?/))) {\n      const params = buildURLQuery(this.fancybox.option(\"Html.vimeo\"));\n      const videoId = encodeURIComponent(rez[1]);\n\n      slide.videoId = videoId;\n      slide.src = `https://player.vimeo.com/video/${videoId}?${params}`;\n      slide.vendor = \"vimeo\";\n\n      type = \"video\";\n    } else if (\n      (rez = src.match(\n        /(?:maps\\.)?google\\.([a-z]{2,3}(?:\\.[a-z]{2})?)\\/(?:(?:(?:maps\\/(?:place\\/(?:.*)\\/)?\\@(.*),(\\d+.?\\d+?)z))|(?:\\?ll=))(.*)?/i\n      ))\n    ) {\n      slide.src = `//maps.google.${rez[1]}/?ll=${(rez[2]\n        ? rez[2] + \"&z=\" + Math.floor(rez[3]) + (rez[4] ? rez[4].replace(/^\\//, \"&\") : \"\")\n        : rez[4] + \"\"\n      ).replace(/\\?/, \"&\")}&output=${rez[4] && rez[4].indexOf(\"layer=c\") > 0 ? \"svembed\" : \"embed\"}`;\n\n      type = \"map\";\n    } else if ((rez = src.match(/(?:maps\\.)?google\\.([a-z]{2,3}(?:\\.[a-z]{2})?)\\/(?:maps\\/search\\/)(.*)/i))) {\n      slide.src = `//maps.google.${rez[1]}/maps?q=${rez[2].replace(\"query=\", \"q=\").replace(\"api=1\", \"\")}&output=embed`;\n\n      type = \"map\";\n    }\n\n    // Guess content type\n    if (!type) {\n      if (src.charAt(0) === \"#\") {\n        type = \"inline\";\n      } else if ((rez = src.match(/\\.(mp4|mov|ogv|webm)((\\?|#).*)?$/i))) {\n        type = \"html5video\";\n\n        slide.format = slide.format || \"video/\" + (rez[1] === \"ogv\" ? \"ogg\" : rez[1]);\n      } else if (src.match(/(^data:image\\/[a-z0-9+\\/=]*,)|(\\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\\?|#).*)?$)/i)) {\n        type = \"image\";\n      } else if (src.match(/\\.(pdf)((\\?|#).*)?$/i)) {\n        type = \"pdf\";\n      }\n    }\n\n    slide.type = type || this.fancybox.option(\"defaultType\", \"image\");\n\n    if (type === \"html5video\" || type === \"video\") {\n      slide.video = Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])({}, this.fancybox.option(\"Html.video\"), slide.video);\n\n      if (slide.width && slide.height) {\n        slide.ratio = parseFloat(slide.width) / parseFloat(slide.height);\n      } else {\n        slide.ratio = slide.ratio || slide.video.ratio;\n      }\n    }\n  }\n\n  /**\n   * Retrieve and set slide content\n   * @param {Object} slide\n   */\n  loadInlineContent(slide) {\n    let $content;\n\n    if (slide.src instanceof HTMLElement) {\n      $content = slide.src;\n    } else if (typeof slide.src === \"string\") {\n      const tmp = slide.src.split(\"#\", 2);\n      const id = tmp.length === 2 && tmp[0] === \"\" ? tmp[1] : tmp[0];\n\n      $content = document.getElementById(id);\n    }\n\n    if ($content) {\n      if (slide.type === \"clone\" || $content.$placeHolder) {\n        $content = $content.cloneNode(true);\n        let attrId = $content.getAttribute(\"id\");\n\n        attrId = attrId ? `${attrId}--clone` : `clone-${this.fancybox.id}-${slide.index}`;\n\n        $content.setAttribute(\"id\", attrId);\n      } else {\n        const $placeHolder = document.createElement(\"div\");\n        $placeHolder.classList.add(\"fancybox-placeholder\");\n        $content.parentNode.insertBefore($placeHolder, $content);\n        $content.$placeHolder = $placeHolder;\n      }\n\n      this.fancybox.setContent(slide, $content);\n    } else {\n      this.fancybox.setError(slide, \"{{ELEMENT_NOT_FOUND}}\");\n    }\n  }\n\n  /**\n   * Makes AJAX request and sets response as slide content\n   * @param {Object} slide\n   */\n  loadAjaxContent(slide) {\n    const fancybox = this.fancybox;\n    const xhr = new XMLHttpRequest();\n\n    fancybox.showLoading(slide);\n\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        if (fancybox.state === \"ready\") {\n          fancybox.hideLoading(slide);\n\n          if (xhr.status === 200) {\n            fancybox.setContent(slide, xhr.responseText);\n          } else {\n            fancybox.setError(slide, xhr.status === 404 ? \"{{AJAX_NOT_FOUND}}\" : \"{{AJAX_FORBIDDEN}}\");\n          }\n        }\n      }\n    };\n\n    xhr.open(\"GET\", slide.src);\n    xhr.send(slide.ajax || null);\n\n    slide.xhr = xhr;\n  }\n\n  /**\n   * Creates iframe as slide content, preloads if needed before displaying\n   * @param {Object} slide\n   */\n  loadIframeContent(slide) {\n    const fancybox = this.fancybox;\n    const $iframe = document.createElement(\"iframe\");\n\n    $iframe.className = \"fancybox__iframe\";\n\n    $iframe.setAttribute(\"id\", `fancybox__iframe_${fancybox.id}_${slide.index}`);\n\n    $iframe.setAttribute(\"allow\", \"autoplay; fullscreen\");\n    $iframe.setAttribute(\"scrolling\", \"auto\");\n\n    slide.$iframe = $iframe;\n\n    if (slide.type !== \"iframe\" || slide.preload === false) {\n      $iframe.setAttribute(\"src\", slide.src);\n\n      this.fancybox.setContent(slide, $iframe);\n\n      return;\n    }\n\n    fancybox.showLoading(slide);\n\n    const $content = document.createElement(\"div\");\n    $content.style.visibility = \"hidden\";\n\n    this.fancybox.setContent(slide, $content);\n\n    $content.appendChild($iframe);\n\n    $iframe.onerror = () => {\n      fancybox.setError(slide, \"{{IFRAME_ERROR}}\");\n    };\n\n    $iframe.onload = () => {\n      fancybox.hideLoading(slide);\n\n      let isFirstLoad = false;\n\n      if ($iframe.dataset.ready !== \"yes\") {\n        $iframe.dataset.ready = \"yes\";\n        isFirstLoad = true;\n      }\n\n      if (!$iframe.src.length) {\n        return;\n      }\n\n      $iframe.parentNode.style.visibility = \"\";\n\n      if (slide.autoSize !== false) {\n        this.autoSizeIframe($iframe);\n      }\n\n      if (isFirstLoad) {\n        fancybox.revealContent(slide);\n      }\n    };\n\n    $iframe.setAttribute(\"src\", slide.src);\n  }\n\n  /**\n   * Set CSS max/min width/height properties of the content to have the correct aspect ratio\n   * @param {Object} slide\n   */\n  setAspectRatio(slide) {\n    let ratio = slide.ratio;\n\n    if (!ratio || !slide.$content) {\n      return;\n    }\n\n    slide.$content.style.maxWidth = \"\";\n    slide.$content.style.maxHeight = \"\";\n\n    let width = slide.$content.offsetWidth;\n    let height = slide.$content.offsetHeight;\n\n    let maxWidth = slide.width;\n    let maxHeight = slide.height;\n\n    if (maxWidth && maxHeight && (width > maxWidth || height > maxHeight)) {\n      let maxRatio = Math.min(maxWidth / width, maxHeight / height);\n\n      width = width * maxRatio;\n      height = height * maxRatio;\n    }\n\n    if (ratio < width / height) {\n      width = height * ratio;\n    } else {\n      height = width / ratio;\n    }\n\n    slide.$content.style.maxWidth = `${width}px`;\n    slide.$content.style.maxHeight = `${height}px`;\n  }\n\n  /**\n   * Adjust the width and height of iframe to fit with content\n   * @param {Object} $iframe\n   */\n  autoSizeIframe($iframe) {\n    if (!$iframe.dataset || $iframe.dataset.ready !== \"yes\") {\n      return;\n    }\n\n    let parentStyle = $iframe.parentNode.style;\n\n    parentStyle.flex = \"1 1 auto\";\n    parentStyle.width = \"\";\n    parentStyle.height = \"\";\n\n    try {\n      const document = $iframe.contentWindow.document,\n        $html = document.getElementsByTagName(\"html\")[0],\n        $body = document.body,\n        style = window.getComputedStyle($iframe.parentNode),\n        paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight),\n        paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);\n\n      // Get rid of vertical scrollbar\n      $body.style.overflow = \"hidden\";\n\n      const width = $html.scrollWidth;\n      parentStyle.width = `${width + paddingX}px`;\n\n      $body.style.overflow = \"\";\n\n      parentStyle.flex = \"\";\n      parentStyle.flexShrink = \"0\";\n      parentStyle.height = `${$body.scrollHeight}px`;\n\n      const height = $html.scrollHeight;\n\n      parentStyle.height = `${height + paddingY}px`;\n    } catch (error) {\n      parentStyle = \"\";\n    }\n  }\n\n  /**\n   * Process `Carousel.onRefresh` event,\n   * trigger iframe autosizing and set content aspect ratio for each slide\n   * @param {Object} fancybox\n   * @param {Object} carousel\n   */\n  onRefresh(fancybox, carousel) {\n    carousel.slides.forEach((slide) => {\n      if (!slide.$el) {\n        return;\n      }\n\n      if (slide.$iframe && slide.autoSize !== false) {\n        this.autoSizeIframe(slide.$iframe);\n      }\n\n      if (slide.ratio) {\n        this.setAspectRatio(slide);\n      }\n    });\n  }\n\n  /**\n   * Process `Carousel.onCreateSlide` event to set content\n   * @param {Object} fancybox\n   * @param {Object} carousel\n   * @param {Object} slide\n   */\n  onCreateSlide(fancybox, carousel, slide) {\n    if (!slide || slide.isDom) {\n      return;\n    }\n\n    switch (slide.type) {\n      case \"html\":\n        this.fancybox.setContent(slide, slide.src);\n        break;\n\n      case \"html5video\":\n        this.fancybox.setContent(\n          slide,\n          this.fancybox\n            .option(\"Html.html5video.tpl\")\n            .replace(/\\{\\{src\\}\\}/gi, slide.src)\n            .replace(\"{{format}}\", slide.format || (slide.html5video && slide.html5video.format) || \"\")\n            .replace(\"{{poster}}\", slide.thumb || \"\")\n        );\n\n        break;\n\n      case \"inline\":\n      case \"clone\":\n        this.loadInlineContent(slide);\n        break;\n\n      case \"ajax\":\n        this.loadAjaxContent(slide);\n        break;\n\n      case \"iframe\":\n      case \"pdf\":\n      case \"video\":\n      case \"map\":\n        this.loadIframeContent(slide);\n\n        break;\n    }\n\n    if (slide.ratio) {\n      this.setAspectRatio(slide);\n    }\n  }\n\n  /**\n   * Process `Carousel.onSelectSlide` event to start video\n   * @param {Object} fancybox\n   * @param {Object} carousel\n   * @param {Object} slide\n   */\n  onSelectSlide(fancybox, carousel, slide) {\n    if (slide.type === \"html5video\") {\n      slide.$el.querySelector(\"video\").play();\n    }\n\n    if (slide.type !== \"video\" || !(slide.$iframe && slide.$iframe.contentWindow)) {\n      return;\n    }\n\n    // This function will be repeatedly called to check\n    // if video iframe has been loaded to send message to start the video\n    const poller = () => {\n      if (slide.state !== \"done\" || !slide.$iframe.contentWindow) {\n        return;\n      }\n\n      let command;\n\n      if (slide.$iframe.isReady) {\n        if (slide.video && slide.video.autoplay) {\n          if (slide.vendor == \"youtube\") {\n            command = {\n              event: \"command\",\n              func: \"playVideo\",\n            };\n          } else {\n            command = {\n              method: \"play\",\n              value: \"true\",\n            };\n          }\n        }\n\n        if (command) {\n          slide.$iframe.contentWindow.postMessage(JSON.stringify(command), \"*\");\n        }\n\n        return;\n      }\n\n      if (slide.vendor === \"youtube\") {\n        command = {\n          event: \"listening\",\n          id: slide.$iframe.getAttribute(\"id\"),\n        };\n\n        slide.$iframe.contentWindow.postMessage(JSON.stringify(command), \"*\");\n      }\n\n      slide.poller = setTimeout(poller, 250);\n    };\n\n    poller();\n  }\n\n  /**\n   * Process `Carousel.onUnselectSlide` event to pause video\n   * @param {Object} fancybox\n   * @param {Object} carousel\n   * @param {Object} slide\n   */\n  onUnselectSlide(fancybox, carousel, slide) {\n    if (slide.type === \"html5video\") {\n      try {\n        slide.$el.querySelector(\"video\").pause();\n      } catch (error) {}\n\n      return;\n    }\n\n    let command = false;\n\n    if (slide.vendor == \"vimeo\") {\n      command = {\n        method: \"pause\",\n        value: \"true\",\n      };\n    } else if (slide.vendor === \"youtube\") {\n      command = {\n        event: \"command\",\n        func: \"pauseVideo\",\n      };\n    }\n\n    if (command && slide.$iframe && slide.$iframe.contentWindow) {\n      slide.$iframe.contentWindow.postMessage(JSON.stringify(command), \"*\");\n    }\n\n    clearTimeout(slide.poller);\n  }\n\n  /**\n   * Process `Carousel.onDeleteSlide` event to do clean up\n   * @param {Object} fancybox\n   * @param {Object} carousel\n   * @param {Object} slide\n   */\n  onDeleteSlide(fancybox, carousel, slide) {\n    // Abort ajax request if exists\n    if (slide.xhr) {\n      slide.xhr.abort();\n      slide.xhr = null;\n    }\n\n    // Unload iframe content if exists\n    if (slide.$iframe) {\n      slide.$iframe.onload = slide.$iframe.onerror = null;\n\n      slide.$iframe.src = \"//about:blank\";\n      slide.$iframe = null;\n    }\n\n    // Clear inline content\n    const $content = slide.$content;\n\n    if (slide.type === \"inline\" && $content) {\n      $content.classList.remove(\"fancybox__content\");\n\n      if ($content.style.display !== \"none\") {\n        $content.style.display = \"none\";\n      }\n\n      if (slide.$closeButton) {\n        slide.$closeButton.remove();\n        slide.$closeButton = null;\n      }\n    }\n\n    const $placeHolder = $content && $content.$placeHolder;\n\n    if ($placeHolder) {\n      $placeHolder.parentNode.insertBefore($content, $placeHolder);\n      $placeHolder.remove();\n      $content.$placeHolder = null;\n    }\n  }\n\n  /**\n   * Process `window.message` event to mark video iframe element as `ready`\n   * @param {Object} e - Event\n   */\n  onMessage(e) {\n    try {\n      let data = JSON.parse(e.data);\n\n      if (e.origin === \"https://player.vimeo.com\") {\n        if (data.event === \"ready\") {\n          for (let $iframe of document.getElementsByClassName(\"fancybox__iframe\")) {\n            if ($iframe.contentWindow === e.source) {\n              $iframe.isReady = 1;\n            }\n          }\n        }\n      } else if (e.origin === \"https://www.youtube-nocookie.com\") {\n        if (data.event === \"onReady\") {\n          document.getElementById(data.id).isReady = 1;\n        }\n      }\n    } catch (ex) {}\n  }\n\n  attach() {\n    this.fancybox.on(this.events);\n\n    window.addEventListener(\"message\", this.onMessage, false);\n  }\n\n  detach() {\n    this.fancybox.off(this.events);\n\n    window.removeEventListener(\"message\", this.onMessage, false);\n  }\n}\n\n// Expose defaults\nHtml.defaults = defaults;\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Fancybox/plugins/Html/Html.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Image/Image.js":
/*!************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/Image/Image.js ***!
  \************************************************************************/
/*! exports provided: Image */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Image\", function() { return Image; });\n/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/utils/extend.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/extend.js\");\n/* harmony import */ var _Panzoom_Panzoom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Panzoom/Panzoom.js */ \"./node_modules/@fancyapps/ui/src/Panzoom/Panzoom.js\");\n\n\n\n\nconst defaults = {\n  // Options for Panzoom instance\n  Panzoom: {\n    maxScale: 1,\n  },\n\n  // Class name for slide element indicating that content can be zoomed in\n  canZoomInClass: \"can-zoom_in\",\n\n  // Class name for slide element indicating that content can be zoomed out\n  canZoomOutClass: \"can-zoom_out\",\n\n  // Do zoom animation from thumbnail image when starting or closing fancybox\n  zoom: true,\n\n  // Animate opacity while zooming\n  zoomOpacity: \"auto\", // \"auto\" | true | false,\n\n  // Zoom animation friction\n  zoomFriction: 0.8,\n\n  // Disable zoom animation if thumbnail is visible only partly\n  ignoreCoveredThumbnail: false,\n\n  // Action to be performed when user clicks on the image\n  click: \"toggleZoom\", // \"toggleZoom\" | \"next\" | \"close\" | null\n\n  // Action to be performed when double-click event is detected on the image\n  doubleClick: null, // \"toggleZoom\" | null\n\n  // Action to be performed when user rotates a wheel button on a pointing device\n  wheel: \"zoom\", // \"zoom\" | \"slide\" | \"close\" | null\n\n  // How image should be resized to fit its container\n  fit: \"contain\", // \"contain\" | \"contain-w\" | \"cover\"\n};\n\n/**\n * Helper method to get actual image dimensions respecting original aspect ratio,\n * this helps to normalise differences across browsers\n * @param {Object} img\n */\nconst getImgSizeInfo = function (img) {\n  const width = img.naturalWidth,\n    height = img.naturalHeight,\n    cWidth = img.width,\n    cHeight = img.height,\n    oRatio = width / height,\n    cRatio = cWidth / cHeight,\n    rez = {\n      width: cWidth,\n      height: cHeight,\n    };\n\n  if (oRatio > cRatio) {\n    rez.height = cWidth / oRatio;\n  } else {\n    rez.width = cHeight * oRatio;\n  }\n\n  rez.left = (cWidth - rez.width) * 0.5;\n  rez.right = width + rez.left;\n\n  return rez;\n};\n\nclass Image {\n  constructor(fancybox) {\n    this.fancybox = fancybox;\n\n    for (const methodName of [\n      // Fancybox\n      \"onReady\",\n      \"onClosing\",\n\n      // Fancybox.Carousel\n      \"onPageChange\",\n      \"onCreateSlide\",\n      \"onRemoveSlide\",\n      \"onRefresh\",\n\n      // Image load/error\n      \"onImageStatusChange\",\n    ]) {\n      this[methodName] = this[methodName].bind(this);\n    }\n\n    this.events = {\n      ready: this.onReady,\n      closing: this.onClosing,\n\n      \"Carousel.change\": this.onPageChange,\n      \"Carousel.createSlide\": this.onCreateSlide,\n      \"Carousel.deleteSlide\": this.onRemoveSlide,\n      \"Carousel.Panzoom.updateMetrics\": this.onRefresh,\n    };\n  }\n\n  /**\n   * Process `ready` event to start zoom-in animation if needed\n   */\n  onReady() {\n    const slide = this.fancybox.getSlide();\n\n    if (slide.state === \"ready\") {\n      this.revealContent(slide);\n    }\n  }\n\n  /**\n   * Process `Carousel.createSlide` event to create image content\n   * @param {Object} fancybox\n   * @param {Object} carousel\n   * @param {Object} slide\n   */\n  onCreateSlide(fancybox, carousel, slide) {\n    // Check if this slide should contain an image\n    if (slide.isDom || slide.html || (slide.type && slide.type !== \"image\")) {\n      return;\n    }\n\n    slide.type = \"image\";\n    slide.state = \"loading\";\n\n    // * Build layout\n    // Container\n    const $content = document.createElement(\"div\");\n    $content.style.visibility = \"hidden\";\n\n    // Image element\n    const $image = document.createElement(\"img\");\n\n    $image.onload = () => this.onImageStatusChange(slide);\n    $image.onerror = () => this.onImageStatusChange(slide);\n\n    $image.src = slide.src;\n    $image.alt = \"\";\n    $image.draggable = false;\n\n    $image.classList.add(\"fancybox__image\");\n\n    if (slide.srcset) {\n      $image.setAttribute(\"srcset\", slide.srcset);\n    }\n\n    if (slide.sizes) {\n      $image.setAttribute(\"sizes\", slide.sizes);\n    }\n\n    slide.$image = $image;\n\n    $content.appendChild($image);\n\n    // Set data attribute if other that default\n    // for example, set `[data-image-fit=\"contain-w\"]`\n    slide.$el.dataset.imageFit = this.fancybox.option(\"Image.fit\");\n\n    slide.$el.style.display = \"none\";\n    slide.$el.offsetHeight; // no need to store this anywhere, the reference is enough\n    slide.$el.style.display = \"\";\n\n    // Append content\n    this.fancybox.setContent(slide, $content);\n\n    // Display loading icon\n    if ($image.complete || $image.error) {\n      $image.onload = $image.onerror = null;\n\n      this.onImageStatusChange(slide);\n    } else if (!$image.complete) {\n      this.fancybox.showLoading(slide);\n    }\n  }\n\n  /**\n   * Make image zoomable and draggable using Panzoom\n   * @param {Object} slide\n   */\n  initSlidePanzoom(slide) {\n    if (slide.Panzoom) {\n      return;\n    }\n\n    //* Initialize Panzoom\n    slide.Panzoom = new _Panzoom_Panzoom_js__WEBPACK_IMPORTED_MODULE_1__[\"Panzoom\"](\n      slide.$el,\n      Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(true, this.fancybox.option(\"Image.Panzoom\"), {\n        content: slide.$image,\n\n        // This will prevent click conflict with fancybox main carousel\n        panOnlyZoomed: true,\n\n        // Disable default click/wheel events; custom callbacks will replace them\n        click: null,\n        doubleClick: null,\n        wheel: null,\n\n        on: {\n          afterAnimate: (panzoom) => {\n            if (slide.state === \"zoomIn\") {\n              panzoom.attachEvents();\n\n              this.fancybox.done(slide);\n            }\n\n            this.handleCursor(slide);\n          },\n          updateMetrics: () => {\n            this.handleCursor(slide);\n          },\n          touchMove: () => {\n            // Prevent any dragging if fancybox main carousel is dragged up/down\n            // (e.g. if close guesture is detected)\n            if (this.fancybox.Carousel.Panzoom.lockAxis) {\n              return false;\n            }\n          },\n        },\n      })\n    );\n\n    // Add `wheel` event handler\n    if (this.fancybox.option(\"Image.wheel\")) {\n      slide.Panzoom.on(\"wheel\", (panzoom, event) => this.onWheel(panzoom, event));\n    }\n\n    // Add `click` event handler\n    if (this.fancybox.option(\"Image.click\")) {\n      slide.Panzoom.on(\"click\", (panzoom, event) => this.onClick(panzoom, event));\n    }\n\n    // Handle double click event to zoom in/out\n    if (this.fancybox.option(\"Image.doubleClick\") === \"toggleZoom\") {\n      slide.Panzoom.on(\"doubleClick\", (panzoom, event) => {\n        if (!event.target.closest(\".fancybox__content\")) {\n          return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        const x = event.clientX - panzoom.$content.getClientRects()[0].left;\n        const y = event.clientY - panzoom.$content.getClientRects()[0].top;\n\n        panzoom.toggleZoom({ x, y });\n      });\n    }\n  }\n\n  /**\n   * Handle image state change\n   * @param {Object} slide\n   */\n  onImageStatusChange(slide) {\n    this.fancybox.hideLoading(slide);\n\n    const $image = slide.$image;\n\n    if (!($image.complete && $image.width && $image.height)) {\n      this.fancybox.setError(slide, \"{{IMAGE_ERROR}}\");\n\n      return;\n    }\n\n    slide.state = \"ready\";\n\n    this.updateDimensions(slide);\n\n    this.initSlidePanzoom(slide);\n\n    this.revealContent(slide);\n  }\n\n  /**\n   * Update image wrapper width to match image width,\n   * this will allow to display elements like close button over the image\n   * if image is resized smaller\n   * @param {Object} slide\n   */\n  updateDimensions(slide) {\n    if (slide.$el.dataset.imageFit !== \"cover\") {\n      const $image = slide.$image;\n      const $content = slide.$content;\n\n      $content.style.maxWidth = \"\";\n\n      const borderWidth = $image.offsetWidth - $image.clientWidth;\n\n      $content.style.maxWidth = `${getImgSizeInfo($image).width + borderWidth}px`;\n    }\n\n    this.handleCursor(slide);\n  }\n\n  /**\n   * Start zoom-in animation if possible, or simply reveal content\n   * @param {Object} slide\n   */\n  revealContent(slide) {\n    this.updateDimensions(slide);\n\n    // Animate only on first run\n    if (\n      this.fancybox.Carousel.prevPage === null &&\n      slide.index === this.fancybox.options.startIndex &&\n      this.canZoom(slide)\n    ) {\n      this.zoomIn();\n    } else {\n      this.fancybox.revealContent(slide);\n    }\n  }\n\n  /**\n   * Determine if it is possible to do zoom-in animation\n   */\n  canZoom(slide) {\n    const fancybox = this.fancybox,\n      $container = fancybox.$container;\n\n    let rez = false;\n\n    if (!fancybox.option(\"Image.zoom\")) {\n      return rez;\n    }\n\n    const $thumb = slide.$thumb;\n\n    if (!$thumb || slide.state === \"loading\") {\n      return rez;\n    }\n\n    // * Check if thumbnail image is really visible\n    $container.style.pointerEvents = \"none\";\n\n    const rect = $thumb.getBoundingClientRect();\n\n    // Check if thumbnail image is actually visible on the screen\n    if (this.fancybox.option(\"Image.ignoreCoveredThumbnail\")) {\n      const visibleTopLeft = document.elementFromPoint(rect.left + 1, rect.top + 1) === $thumb;\n      const visibleBottomRight = document.elementFromPoint(rect.right - 1, rect.bottom - 1) === $thumb;\n\n      rez = visibleTopLeft && visibleBottomRight;\n    } else {\n      rez = document.elementFromPoint(rect.left + rect.width * 0.5, rect.top + rect.height * 0.5) === $thumb;\n    }\n\n    $container.style.pointerEvents = \"\";\n\n    return rez;\n  }\n\n  /**\n   * Get zoom info for selected slide\n   * @param {Object} slide\n   */\n  getZoomInfo(slide) {\n    const $thumb = slide.$thumb,\n      thumbRect = $thumb.getBoundingClientRect(),\n      thumbWidth = thumbRect.width,\n      thumbHeight = thumbRect.height,\n      contentRect = slide.$content.getBoundingClientRect(),\n      contentDim = getImgSizeInfo(slide.$image),\n      contentWidth = contentDim.width,\n      contentHeight = contentDim.height,\n      shiftedTop = contentRect.top + contentHeight * 0.5 - (thumbRect.top + thumbHeight * 0.5),\n      shiftedLeft = contentRect.left + contentWidth * 0.5 - (thumbRect.left + thumbWidth * 0.5);\n\n    // Check if need to update opacity\n    let opacity = this.fancybox.option(\"Image.zoomOpacity\");\n\n    if (opacity === \"auto\") {\n      opacity = Math.abs(thumbWidth / thumbHeight - contentWidth / contentHeight) > 0.1;\n    }\n\n    return {\n      top: shiftedTop,\n      left: shiftedLeft,\n      scale: thumbRect.width / contentWidth,\n      opacity: opacity,\n    };\n  }\n  /**\n   * Perform zoom-in animation\n   */\n  zoomIn() {\n    const fancybox = this.fancybox;\n\n    // Skip if initialization of main carousel is not yet complete\n    // as it will give incorrect element position calculations\n    // (and animation will later start in `onReady` event handler)\n    if (fancybox.Carousel.state === \"init\") {\n      return;\n    }\n\n    const slide = fancybox.getSlide(),\n      Panzoom = slide.Panzoom;\n\n    const { top, left, scale, opacity } = this.getZoomInfo(slide);\n\n    slide.state = \"zoomIn\";\n\n    // Disable event listeners while animation runs\n    Panzoom.detachEvents();\n\n    fancybox.trigger(\"reveal\", slide);\n\n    // Scale and move to start position\n    Panzoom.panTo({\n      x: left * -1,\n      y: top * -1,\n      scale: scale,\n      friction: 0,\n      ignoreBounds: true,\n    });\n\n    slide.$content.style.visibility = \"\";\n\n    if (opacity === true) {\n      Panzoom.on(\"afterTransform\", (panzoom) => {\n        if (slide.state === \"zoomIn\" || slide.state === \"zoomOut\") {\n          panzoom.$content.style.opacity = Math.min(1, panzoom.current.scale);\n        }\n      });\n    }\n\n    // Animate back to original position\n    Panzoom.panTo({\n      x: 0,\n      y: 0,\n      scale: 1,\n      friction: this.fancybox.option(\"Image.zoomFriction\"),\n    });\n  }\n\n  /**\n   * Perform zoom-out animation\n   */\n  zoomOut() {\n    const fancybox = this.fancybox,\n      slide = fancybox.getSlide(),\n      Panzoom = slide.Panzoom;\n\n    if (!Panzoom) {\n      return;\n    }\n\n    slide.state = \"zoomOut\";\n    fancybox.state = \"customClosing\";\n\n    if (slide.$caption) {\n      slide.$caption.style.visibility = \"hidden\";\n    }\n\n    let friction = this.fancybox.option(\"Image.zoomFriction\") * 0.75;\n\n    const animatePosition = () => {\n      const { top, left, scale } = this.getZoomInfo(slide);\n\n      Panzoom.panTo({\n        x: left * -1,\n        y: top * -1,\n        scale: scale,\n        ignoreBounds: true,\n        friction: friction,\n      });\n\n      // Gradually increase speed\n      friction *= 0.98;\n    };\n\n    // Page scrolling will cause thumbnail to change position on the display,\n    // therefore animation end position has to be recalculated after each page scroll\n    window.addEventListener(\"scroll\", animatePosition);\n\n    Panzoom.on(\"afterAnimate\", () => {\n      window.removeEventListener(\"scroll\", animatePosition);\n      fancybox.destroy();\n    });\n\n    animatePosition();\n  }\n\n  /**\n   * Set the type of mouse cursor to indicate if content is zoomable\n   * @param {Object} slide\n   */\n  handleCursor(slide) {\n    const panzoom = slide.Panzoom;\n    const clickAction = this.fancybox.option(\"Image.click\");\n    const classList = slide.$el.classList;\n\n    if (panzoom && clickAction === \"toggleZoom\") {\n      const canZoom =\n        panzoom && panzoom.current.scale === 1 && panzoom.option(\"maxScale\") - panzoom.current.scale > 0.01;\n\n      classList[canZoom ? \"add\" : \"remove\"](this.fancybox.option(\"Image.canZoomInClass\"));\n    } else if (clickAction === \"close\") {\n      classList.add(this.fancybox.option(\"Image.canZoomOutClass\"));\n    }\n  }\n\n  /**\n   * Handle `Panzoom.wheel` event\n   * @param {Object} panzoom\n   * @param {Object} event\n   */\n  onWheel(panzoom, event) {\n    switch (this.fancybox.option(\"Image.wheel\")) {\n      case \"zoom\":\n        panzoom.zoomWithWheel(event);\n\n        break;\n\n      case \"close\":\n        this.fancybox.close();\n\n        break;\n\n      case \"slide\":\n        this.fancybox[event.deltaY < 0 ? \"prev\" : \"next\"]();\n\n        break;\n    }\n\n    event.preventDefault();\n  }\n\n  /**\n   * Handle `Panzoom.click` event\n   * @param {Object} panzoom\n   * @param {Object} event\n   */\n  onClick(panzoom, event) {\n    if (\n      this.fancybox.Carousel.Panzoom.drag.distance >= 6 ||\n      this.fancybox.Carousel.Panzoom.lockAxis ||\n      !(event.target.tagName == \"IMG\" || event.target.classList.contains(\"fancybox__content\"))\n    ) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    switch (this.fancybox.option(\"Image.click\")) {\n      case \"toggleZoom\":\n        const x = event.clientX - panzoom.$content.getClientRects()[0].left;\n        const y = event.clientY - panzoom.$content.getClientRects()[0].top;\n\n        panzoom.toggleZoom({ x, y });\n\n        break;\n      case \"close\":\n        this.fancybox.close();\n        break;\n\n      case \"next\":\n        this.fancybox.next();\n        break;\n\n      case \"prev\":\n        this.fancybox.prev();\n        break;\n    }\n  }\n\n  /**\n   * Handle `Carousel.refresh` event to call content resizer\n   * @param {Object} fancybox\n   * @param {Object} carousel\n   */\n  onRefresh(fancybox, carousel) {\n    carousel.slides.forEach((slide) => {\n      if (slide.Panzoom) {\n        this.updateDimensions(slide);\n      }\n    });\n  }\n\n  /**\n   * Handle `Carousel.deleteSlide` event to do clean up the slide\n   * @param {Object} fancybox\n   * @param {Object} carousel\n   * @param {Object} slide\n   */\n  onRemoveSlide(fancybox, carousel, slide) {\n    if (slide.$image) {\n      slide.$el.classList.remove(fancybox.option(\"Image.canZoomInClass\"));\n\n      slide.$image.onload = slide.$image.onerror = null;\n\n      slide.$image.remove();\n      slide.$image = null;\n    }\n\n    if (slide.Panzoom) {\n      slide.Panzoom.destroy();\n      slide.Panzoom = null;\n    }\n\n    delete slide.$el.dataset.imageFit;\n  }\n\n  /**\n   * Handle `closing` event event to clean up all slides and to start zoom-out animation\n   * @param {Object} fancybox\n   */\n  onClosing(fancybox) {\n    // Remove events\n    fancybox.Carousel.slides.forEach((slide) => {\n      if (slide.$image) {\n        slide.$image.onload = slide.$image.onerror = null;\n      }\n\n      if (slide.Panzoom) {\n        slide.Panzoom.detachEvents();\n      }\n    });\n\n    // If possible, start the zoom animation, it will interrupt the default closing process\n    if (this.fancybox.state === \"closing\" && this.canZoom(fancybox.getSlide())) {\n      this.zoomOut();\n    }\n  }\n\n  /**\n   * Handle `Carousel.change` event to reset zoom level for any zoomed in/out content\n   * and to revel content of the current page\n   * @param {Object} fancybox\n   * @param {Object} carousel\n   */\n  onPageChange(fancybox, carousel) {\n    const currSlide = fancybox.getSlide();\n\n    carousel.slides.forEach((slide) => {\n      if (!slide.Panzoom || slide.state !== \"done\") {\n        return;\n      }\n\n      if (slide.index === currSlide.index) {\n        if (carousel.Panzoom.velocity.x === 0) {\n          this.revealContent(slide);\n        }\n\n        return;\n      }\n\n      slide.Panzoom.panTo({\n        x: 0,\n        y: 0,\n        scale: 1,\n        friction: 0.8,\n      });\n    });\n  }\n\n  attach() {\n    this.fancybox.on(this.events);\n  }\n\n  detach() {\n    this.fancybox.off(this.events);\n  }\n}\n\n// Expose defaults\nImage.defaults = defaults;\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Fancybox/plugins/Image/Image.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/ScrollLock/ScrollLock.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/ScrollLock/ScrollLock.js ***!
  \**********************************************************************************/
/*! exports provided: ScrollLock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollLock\", function() { return ScrollLock; });\n/* harmony import */ var _src_shared_utils_isScrollable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/shared/utils/isScrollable.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/isScrollable.js\");\n\n\nclass ScrollLock {\n  constructor(fancybox) {\n    this.fancybox = fancybox;\n    this.viewport = null;\n\n    this.pendingUpdate = null;\n\n    for (const methodName of [\"onReady\", \"onResize\", \"onTouchstart\", \"onTouchmove\"]) {\n      this[methodName] = this[methodName].bind(this);\n    }\n  }\n\n  /**\n   * Process `initLayout` event to attach event listeners and resize viewport if needed\n   */\n  onReady() {\n    //* Support Visual Viewport API\n    // https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API\n    const viewport = window.visualViewport;\n\n    if (viewport) {\n      this.viewport = viewport;\n      this.startY = 0;\n\n      viewport.addEventListener(\"resize\", this.onResize);\n\n      this.updateViewport();\n    }\n\n    //* Prevent bouncing while scrolling on mobile devices\n    window.addEventListener(\"touchstart\", this.onTouchstart, { passive: false });\n    window.addEventListener(\"touchmove\", this.onTouchmove, { passive: false });\n  }\n\n  /**\n   * Handle `resize` event to call `updateViewport`\n   */\n  onResize() {\n    this.updateViewport();\n  }\n\n  /**\n   * Scale $container proportionally to actually fit inside browser,\n   * e.g., disable viewport zooming\n   */\n  updateViewport() {\n    const fancybox = this.fancybox,\n      viewport = this.viewport,\n      scale = viewport.scale,\n      $container = fancybox.$container;\n\n    if (!$container) {\n      return;\n    }\n\n    let width = \"\",\n      height = \"\",\n      transform = \"\";\n\n    if (Math.abs(scale - 1) > 0.1) {\n      width = `${viewport.width * scale}px`;\n      height = `${viewport.height * scale}px`;\n      transform = `translate3d(${viewport.offsetLeft}px, ${viewport.offsetTop}px, 0) scale(${1 / scale})`;\n    }\n\n    $container.style.width = width;\n    $container.style.height = height;\n    $container.style.transform = transform;\n  }\n\n  /**\n   * Handle `touchstart` event to mark drag start position\n   * @param {Object} event\n   */\n  onTouchstart(event) {\n    this.startY = event.touches ? event.touches[0].screenY : event.screenY;\n  }\n\n  /**\n   * Handle `touchmove` event to fix scrolling on mobile devices (iOS)\n   * @param {Object} event\n   */\n  onTouchmove(event) {\n    const startY = this.startY;\n    const zoom = window.innerWidth / window.document.documentElement.clientWidth;\n\n    if (event.touches.length > 1 || zoom !== 1) {\n      return;\n    }\n\n    const target = event.target;\n    const el = Object(_src_shared_utils_isScrollable_js__WEBPACK_IMPORTED_MODULE_0__[\"isScrollable\"])(target);\n\n    if (!el) {\n      event.preventDefault();\n      return;\n    }\n\n    const style = window.getComputedStyle(el);\n    const height = parseInt(style.getPropertyValue(\"height\"), 10);\n\n    const curY = event.touches ? event.touches[0].screenY : event.screenY;\n\n    const isAtTop = startY <= curY && el.scrollTop === 0;\n    const isAtBottom = startY >= curY && el.scrollHeight - el.scrollTop === height;\n\n    if (isAtTop || isAtBottom) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * Clean everything up\n   */\n  cleanup() {\n    if (this.pendingUpdate) {\n      cancelAnimationFrame(this.pendingUpdate);\n      this.pendingUpdate = null;\n    }\n\n    const viewport = this.viewport;\n\n    if (viewport) {\n      viewport.removeEventListener(\"resize\", this.onResize);\n      this.viewport = null;\n    }\n\n    window.removeEventListener(\"touchstart\", this.onTouchstart, false);\n    window.removeEventListener(\"touchmove\", this.onTouchmove, false);\n  }\n\n  attach() {\n    this.fancybox.on(\"initLayout\", this.onReady);\n  }\n\n  detach() {\n    this.fancybox.off(\"initLayout\", this.onReady);\n\n    this.cleanup();\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Fancybox/plugins/ScrollLock/ScrollLock.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Thumbs/Thumbs.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/Thumbs/Thumbs.js ***!
  \**************************************************************************/
/*! exports provided: Thumbs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Thumbs\", function() { return Thumbs; });\n/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/utils/extend.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/extend.js\");\n/* harmony import */ var _Carousel_Carousel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Carousel/Carousel.js */ \"./node_modules/@fancyapps/ui/src/Carousel/Carousel.js\");\n\n\n\nconst defaults = {\n  // Automatically show thumbnails when opened\n  autoStart: true,\n  // The minimum number of images in the gallery to display thumbnails\n  minSlideCount: 3,\n  // Keyboard shortcut to toggle thumbnail container\n  key: \"t\",\n};\n\nclass Thumbs {\n  constructor(fancybox) {\n    this.fancybox = fancybox;\n\n    this.$wrap = null;\n    this.state = \"init\";\n\n    for (const methodName of [\"onReady\", \"onClosing\", \"onKeydown\"]) {\n      this[methodName] = this[methodName].bind(this);\n    }\n\n    this.events = {\n      ready: this.onReady,\n      closing: this.onClosing,\n      keydown: this.onKeydown,\n    };\n  }\n\n  /**\n   * Process `ready` event to build the layout\n   */\n  onReady() {\n    if (this.fancybox.option(\"Thumbs.autoStart\") === true) {\n      this.initLayout();\n    }\n  }\n\n  /**\n   * Process `closing` event to disable all events\n   */\n  onClosing() {\n    if (this.Carousel) {\n      this.Carousel.Panzoom.detachEvents();\n    }\n  }\n\n  /**\n   * Process `keydown` event to enable thumbnail list toggling using keyboard key\n   * @param {Object} fancybox\n   * @param {String} key\n   */\n  onKeydown(fancybox, key) {\n    if (key === fancybox.option(\"Thumbs.key\")) {\n      this.toggle();\n    }\n  }\n\n  /**\n   * Build layout and init thumbnail Carousel\n   */\n  initLayout() {\n    if (this.state !== \"init\") {\n      return;\n    }\n\n    // Get slides, skip if the total number is less than the minimum\n    const slides = this.getSlides();\n\n    if (slides.length < this.fancybox.option(\"Thumbs.minSlideCount\")) {\n      return false;\n    }\n\n    // Create wrapping element and append to layout\n    const $wrap = document.createElement(\"div\");\n\n    $wrap.classList.add(`fancybox__thumbs`);\n\n    this.fancybox.$container.appendChild($wrap);\n\n    // Initialise thumbnail carousel with all slides\n    this.Carousel = new _Carousel_Carousel_js__WEBPACK_IMPORTED_MODULE_1__[\"Carousel\"](\n      $wrap,\n      Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(\n        true,\n        {\n          Dots: false,\n          Navigation: false,\n          Sync: {\n            friction: 0,\n          },\n          infinite: false,\n          center: true,\n          fill: true,\n          dragFree: true,\n          slidesPerPage: 1,\n          preload: 1,\n        },\n        this.fancybox.option(\"Thumbs.Carousel\"),\n        {\n          Sync: {\n            with: this.fancybox.Carousel,\n          },\n          slides: slides,\n        }\n      )\n    );\n\n    // Slide carousel on wheel event\n    this.Carousel.Panzoom.on(\"wheel\", (panzoom, event) => {\n      event.preventDefault();\n\n      this.fancybox[event.deltaY < 0 ? \"prev\" : \"next\"]();\n    });\n\n    this.$wrap = $wrap;\n    this.state = \"ready\";\n  }\n\n  /**\n   * Process all fancybox slides to get all thumbnail images\n   */\n  getSlides() {\n    const slides = [];\n\n    this.fancybox.items.forEach((slide) => {\n      const thumb = slide.thumb;\n\n      if (thumb) {\n        slides.push({\n          html: `<div class=\"fancybox__thumb\" style=\"background-image:url(${thumb})\"></div>`,\n          customClass: `has-thumb has-${slide.type || \"image\"}`,\n        });\n      }\n    });\n\n    return slides;\n  }\n\n  /**\n   * Toggle visibility of thumbnail list\n   * Tip: you can use `Fancybox.getInstance().plugins.Thumbs.toggle()` from anywhere in your code\n   */\n  toggle() {\n    if (this.state === \"ready\") {\n      this.Carousel.Panzoom.detachEvents();\n\n      this.$wrap.style.display = \"none\";\n\n      this.state = \"hidden\";\n\n      return;\n    }\n\n    if (this.state === \"hidden\") {\n      this.$wrap.style.display = \"\";\n\n      this.Carousel.Panzoom.attachEvents();\n\n      this.state = \"ready\";\n\n      return;\n    }\n\n    this.initLayout();\n  }\n\n  /**\n   * Reset the state\n   */\n  cleanup() {\n    if (this.Carousel) {\n      this.Carousel.destroy();\n      this.Carousel = null;\n    }\n\n    if (this.$wrap) {\n      this.$wrap.remove();\n      this.$wrap = null;\n    }\n\n    this.state = \"init\";\n  }\n\n  attach() {\n    this.fancybox.on(this.events);\n  }\n\n  detach() {\n    this.fancybox.off(this.events);\n\n    this.cleanup();\n  }\n}\n\n// Expose defaults\nThumbs.defaults = defaults;\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Fancybox/plugins/Thumbs/Thumbs.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/index.js ***!
  \******************************************************************/
/*! exports provided: Plugins */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plugins\", function() { return Plugins; });\n/* harmony import */ var _ScrollLock_ScrollLock_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScrollLock/ScrollLock.js */ \"./node_modules/@fancyapps/ui/src/Fancybox/plugins/ScrollLock/ScrollLock.js\");\n/* harmony import */ var _Thumbs_Thumbs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Thumbs/Thumbs.js */ \"./node_modules/@fancyapps/ui/src/Fancybox/plugins/Thumbs/Thumbs.js\");\n/* harmony import */ var _Html_Html_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Html/Html.js */ \"./node_modules/@fancyapps/ui/src/Fancybox/plugins/Html/Html.js\");\n/* harmony import */ var _Image_Image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Image/Image.js */ \"./node_modules/@fancyapps/ui/src/Fancybox/plugins/Image/Image.js\");\n/* harmony import */ var _Hash_Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hash/Hash.js */ \"./node_modules/@fancyapps/ui/src/Fancybox/plugins/Hash/Hash.js\");\n\n\n\n\n\n\nconst Plugins = {\n  ScrollLock: _ScrollLock_ScrollLock_js__WEBPACK_IMPORTED_MODULE_0__[\"ScrollLock\"],\n  Thumbs: _Thumbs_Thumbs_js__WEBPACK_IMPORTED_MODULE_1__[\"Thumbs\"],\n  Html: _Html_Html_js__WEBPACK_IMPORTED_MODULE_2__[\"Html\"],\n  Image: _Image_Image_js__WEBPACK_IMPORTED_MODULE_3__[\"Image\"],\n  Hash: _Hash_Hash_js__WEBPACK_IMPORTED_MODULE_4__[\"Hash\"],\n};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Fancybox/plugins/index.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Panzoom/Panzoom.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Panzoom/Panzoom.js ***!
  \***********************************************************/
/*! exports provided: Panzoom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Panzoom\", function() { return Panzoom; });\n/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils/extend.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/extend.js\");\n/* harmony import */ var _shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils/round.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/round.js\");\n/* harmony import */ var _shared_utils_ResizeObserver_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils/ResizeObserver.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/ResizeObserver.js\");\n/* harmony import */ var _shared_utils_clearTextSelection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/utils/clearTextSelection.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/clearTextSelection.js\");\n/* harmony import */ var _shared_utils_isScrollable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/utils/isScrollable.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/isScrollable.js\");\n/* harmony import */ var _shared_utils_getTextNodeFromPoint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/utils/getTextNodeFromPoint.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/getTextNodeFromPoint.js\");\n/* harmony import */ var _shared_utils_getDimensions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shared/utils/getDimensions.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/getDimensions.js\");\n/* harmony import */ var _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shared/Base/Base.js */ \"./node_modules/@fancyapps/ui/src/shared/Base/Base.js\");\n/* harmony import */ var _plugins_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/index.js */ \"./node_modules/@fancyapps/ui/src/Panzoom/plugins/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst defaults = {\n  // Disable dragging if scale level is equal to value of `baseScale` option\n  panOnlyZoomed: false,\n\n  // Lock axis while dragging,\n  // possible values: false | \"x\" | \"y\" | \"xy\"\n  lockAxis: false,\n\n  // * Friction values are inside [0, 1), where 0 would change instantly, but 0.99 would update extremely slowly\n\n  // Friction while panning/dragging\n  friction: 0.72,\n\n  // Friction while decelerating after drag end\n  decelFriction: 0.92,\n\n  // Friction while scaling\n  zoomFriction: 0.72,\n\n  // Bounciness after hitting the edge\n  bounceForce: 0.1,\n\n  // Initial scale level\n  baseScale: 1,\n\n  // Minimum scale level\n  minScale: 1,\n\n  // Maximum scale level\n  maxScale: 2,\n\n  // Default scale step while scaling\n  step: 0.5,\n\n  // Should content be centered while scaling or moved towards given coordintes,\n  // if coordinates are outside the content\n  zoomInCentered: true,\n\n  // Enable pinch gesture to zoom in/out using two fingers\n  pinchToZoom: true,\n\n  // Allow to select text,\n  // if enabled, dragging will be disabled when text selection is detected\n  textSelection: true,\n\n  // Add `click` event listener,\n  // possible values: true | false | function | \"toggleZoom\"\n  click: \"toggleZoom\",\n\n  // Delay required for two consecutive clicks to be interpreted as a double-click\n  clickDelay: 250,\n\n  // Enable `doubleClick` event,\n  // possible values: true | false | function | \"toggleZoom\"\n  doubleClick: false,\n\n  // Add `wheel` event listener,\n  // possible values: true | false | function |  \"zoom\"\n  wheel: \"zoom\",\n\n  // Value for zoom on mouse wheel\n  wheelFactor: 30,\n\n  // Number of wheel events after which it should stop preventing default behaviour of mouse wheel\n  wheelLimit: 3,\n\n  // Enable touch guestures\n  touch: true,\n\n  // Class name added to `$viewport` element to indicate if content is draggable\n  draggableClass: \"is-draggable\",\n\n  // Class name added to `$viewport` element to indicate that user is currently dragging\n  draggingClass: \"is-dragging\",\n};\n\nclass Panzoom extends _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_7__[\"Base\"] {\n  /**\n   * Panzoom constructor\n   * @constructs Panzoom\n   * @param {HTMLElement} $viewport Panzoom container\n   * @param {Object} [options] Options for Panzoom\n   */\n  constructor($viewport, options = {}) {\n    options = Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(true, {}, defaults, options);\n\n    super(options);\n\n    if (!($viewport instanceof HTMLElement)) {\n      throw new Error(\"Viewport not found\");\n    }\n\n    this.state = \"init\";\n\n    this.$viewport = $viewport;\n\n    // Bind event handlers for referencability\n    for (const methodName of [\"onPointerDown\", \"onPointerMove\", \"onPointerUp\", \"onWheel\", \"onClick\"]) {\n      this[methodName] = this[methodName].bind(this);\n    }\n\n    // Make sure content element exists\n    this.$content = this.option(\"content\");\n\n    if (!this.$content) {\n      this.$content = this.$viewport.querySelector(\".panzoom__content\");\n    }\n\n    if (!this.$content) {\n      throw new Error(\"Content not found\");\n    }\n\n    if (this.option(\"textSelection\") === false) {\n      this.$viewport.classList.add(\"not-selectable\");\n    }\n\n    this.resetValues();\n\n    this.attachPlugins(Panzoom.Plugins);\n\n    this.trigger(\"init\");\n\n    this.handleContent();\n\n    this.attachEvents();\n\n    this.trigger(\"ready\");\n\n    // Finalize initialization\n    if (this.state === \"init\") {\n      const baseScale = this.option(`baseScale`);\n\n      if (baseScale === 1) {\n        this.state = \"ready\";\n\n        this.handleCursor();\n      } else {\n        this.panTo({ scale: baseScale, friction: 0 });\n      }\n    }\n  }\n\n  /**\n   * Check content type, add `load` and `error` callbacks for image\n   */\n  handleContent() {\n    if (this.$content instanceof HTMLImageElement) {\n      // Callback to be called after image has finished loading\n      const done = () => {\n        const imgWidth = this.$content.naturalWidth;\n        this.maxScale = this.option(\"maxScale\");\n\n        this.options.maxScale = function () {\n          const wrapWidth = this.contentDim.width;\n\n          return imgWidth > 0 && wrapWidth > 0 ? (imgWidth / wrapWidth) * this.maxScale : this.maxScale;\n        };\n\n        this.updateMetrics();\n\n        this.trigger(imgWidth > 0 ? \"load\" : \"error\");\n      };\n\n      if (this.$content.complete !== true) {\n        this.$content.onload = () => done();\n        this.$content.onerror = () => done();\n      } else {\n        done();\n      }\n    } else {\n      this.updateMetrics();\n    }\n  }\n\n  /**\n   * Restore instance variables to default values\n   */\n  resetValues() {\n    this.viewportDim = {\n      top: 0,\n      left: 0,\n      width: 0,\n      height: 0,\n    };\n\n    this.contentDim = {\n      width: 0,\n      height: 0,\n    };\n\n    this.friction = this.option(\"friction\");\n\n    this.current = { x: 0, y: 0, scale: 1 };\n    this.velocity = { x: 0, y: 0, scale: 0 };\n\n    this.pan = { x: 0, y: 0, scale: 1 };\n\n    this.drag = {\n      startTime: null,\n\n      firstPosition: null,\n\n      startPosition: null,\n      startPoint: null,\n      startDistance: null,\n\n      endPosition: null,\n      endPoint: null,\n\n      distance: 0,\n      distanceX: 0,\n      distanceY: 0,\n\n      elapsedTime: 0,\n    };\n\n    this.lockAxis = null;\n\n    this.pendingAnimateUpdate = null;\n    this.pendingResizeUpdate = null;\n\n    this.pointers = [];\n  }\n\n  /**\n   * Update readings of viewport and content dimensions\n   */\n  updateMetrics() {\n    let { top, left, width, height } = this.$viewport.getBoundingClientRect();\n\n    const styles = window.getComputedStyle(this.$viewport);\n\n    width -= parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);\n    height -= parseFloat(styles.paddingTop) + parseFloat(styles.paddingBottom);\n\n    this.viewportDim = { top, left, width, height };\n\n    this.contentDim = {\n      width: this.option(\"width\", Object(_shared_utils_getDimensions_js__WEBPACK_IMPORTED_MODULE_6__[\"getFullWidth\"])(this.$content)),\n      height: this.option(\"hidth\", Object(_shared_utils_getDimensions_js__WEBPACK_IMPORTED_MODULE_6__[\"getFullHeight\"])(this.$content)),\n    };\n\n    this.trigger(\"updateMetrics\");\n\n    this.updateBounds();\n  }\n\n  /**\n   * Update current boundaries\n   * @param {number} [scale] Optional scale of content\n   */\n  updateBounds(scale) {\n    const boundX = { from: 0, to: 0 };\n    const boundY = { from: 0, to: 0 };\n\n    if (!scale) {\n      scale = this.velocity.scale ? this.pan.scale : this.current.scale;\n    }\n\n    if (scale < 1) {\n      return [boundX, boundY];\n    }\n\n    const contentDim = this.contentDim;\n    const viewportDim = this.viewportDim;\n\n    const currentWidth = contentDim.width * scale;\n    const currentHeight = contentDim.height * scale;\n\n    boundX.to = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])((currentWidth - contentDim.width) * 0.5);\n\n    if (contentDim.width > viewportDim.width) {\n      boundX.from = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])(boundX.to + viewportDim.width - currentWidth);\n    } else {\n      boundX.from = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])(boundX.to * -1);\n    }\n\n    boundY.to = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])((currentHeight - contentDim.height) * 0.5);\n\n    if (contentDim.height > viewportDim.height) {\n      boundY.from = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])(boundY.to + viewportDim.height - currentHeight);\n    } else {\n      boundY.from = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])(boundY.to * -1);\n    }\n\n    this.boundX = boundX;\n    this.boundY = boundY;\n\n    this.trigger(\"updateBounds\", scale);\n\n    return [this.boundX, this.boundY];\n  }\n\n  /**\n   * Increase zoom level\n   * @param {Number} [step] Zoom ratio; `0.5` would increase scale from 1 to 1.5\n   */\n  zoomIn(step) {\n    this.zoomTo(this.current.scale + (step || this.option(\"step\")));\n  }\n\n  /**\n   * Decrease zoom level\n   * @param {Number} [step] Zoom ratio; `0.5` would decrease scale from 1.5 to 1\n   */\n  zoomOut(step) {\n    this.zoomTo(this.current.scale - (step || this.option(\"step\")));\n  }\n\n  /**\n   * Toggles zoom level between max and base levels\n   * @param {Object} [options] Additional options\n   */\n  toggleZoom(props = {}) {\n    const maxScale = this.option(\"maxScale\");\n    const baseScale = this.option(\"baseScale\");\n\n    this.zoomTo(this.current.scale > baseScale + (maxScale - baseScale) * 0.5 ? baseScale : maxScale, props);\n  }\n\n  /**\n   * Animates to given zoom level\n   * @param {Number} scale New zoom level\n   * @param {Object} [options] Additional options\n   */\n  zoomTo(scale, options = {}) {\n    let { x = null, y = null, friction = this.option(\"zoomFriction\") } = options;\n\n    if (!scale) {\n      scale = this.option(\"baseScale\");\n    }\n\n    scale = Math.max(Math.min(scale, this.option(\"maxScale\")), this.option(\"minScale\"));\n\n    const width = this.contentDim.width;\n    const height = this.contentDim.height;\n\n    const currentWidth = width * this.current.scale;\n    const currentHeight = height * this.current.scale;\n\n    const nextWidth = width * scale;\n    const nextHeight = height * scale;\n\n    if (x === null) {\n      x = currentWidth * 0.5;\n    }\n\n    if (y === null) {\n      y = currentHeight * 0.5;\n    }\n\n    if (this.option(\"zoomInCentered\") === false) {\n      if (x < currentWidth * 0.5) {\n        x = currentWidth;\n      }\n\n      if (x > currentWidth) {\n        x = 0;\n      }\n\n      if (y < 0) {\n        y = currentHeight;\n      }\n\n      if (y > currentHeight) {\n        y = 0;\n      }\n    }\n\n    const percentXInCurrentBox = currentWidth > 0 ? x / currentWidth : 0;\n    const percentYInCurrentBox = currentHeight > 0 ? y / currentHeight : 0;\n\n    let deltaX = (nextWidth - currentWidth) * (percentXInCurrentBox - 0.5);\n    let deltaY = (nextHeight - currentHeight) * (percentYInCurrentBox - 0.5);\n\n    if (Math.abs(deltaX) < 1) {\n      deltaX = 0;\n    }\n\n    if (Math.abs(deltaY) < 1) {\n      deltaY = 0;\n    }\n\n    x = this.current.x - deltaX;\n    y = this.current.y - deltaY;\n\n    this.panTo({ x, y, scale, friction });\n  }\n\n  /**\n   * Animates to given positon and/or zoom level\n   * @param {Object} [options] Additional options\n   */\n  panTo(options) {\n    let {\n      x = 0,\n      y = 0,\n      scale = this.current.scale,\n      friction = this.option(\"friction\"),\n      ignoreBounds = false,\n    } = options;\n\n    if (!friction) {\n      this.stopMoving();\n    }\n\n    if (ignoreBounds !== true) {\n      const [boundX, boundY] = this.updateBounds(scale);\n\n      if (boundX) {\n        x = Math.max(Math.min(x, boundX.to), boundX.from);\n      }\n\n      if (boundY) {\n        y = Math.max(Math.min(y, boundY.to), boundY.from);\n      }\n    }\n\n    // Check if there is anything to animate\n    if (\n      friction > 0 &&\n      (Math.abs(x - this.current.x) > 0.1 ||\n        Math.abs(y - this.current.y) > 0.1 ||\n        Math.abs(scale - this.current.scale) > 0.1)\n    ) {\n      this.state = \"panning\";\n\n      this.friction = friction;\n\n      this.pan = {\n        x,\n        y,\n        scale,\n      };\n\n      this.velocity = {\n        x: (1 / this.friction - 1) * (x - this.current.x),\n        y: (1 / this.friction - 1) * (y - this.current.y),\n        scale: (1 / this.friction - 1) * (scale - this.current.scale),\n      };\n\n      this.animate();\n\n      return this;\n    }\n\n    if (this.pendingAnimateUpdate) {\n      cancelAnimationFrame(this.pendingAnimateUpdate);\n      this.pendingAnimateUpdate = null;\n    }\n\n    this.state = \"ready\";\n\n    this.stopMoving();\n\n    this.current = { x, y, scale };\n\n    this.transform();\n\n    this.handleCursor();\n\n    this.trigger(\"afterAnimate\", true);\n\n    return this;\n  }\n\n  /**\n   * Start animation or process animation frame\n   */\n  animate() {\n    // Skip if already waiting for the next RAF\n    if (this.pendingAnimateUpdate) {\n      return;\n    }\n\n    // Update velocity depending on bounds and drag speed\n    this.applyBoundForce();\n    this.applyDragForce();\n\n    this.velocity.x *= this.friction;\n    this.velocity.y *= this.friction;\n\n    this.velocity.scale *= this.friction;\n\n    this.current.x += this.velocity.x;\n    this.current.y += this.velocity.y;\n\n    this.current.scale += this.velocity.scale;\n\n    if (\n      this.state == \"dragging\" ||\n      this.state == \"pointerdown\" ||\n      Math.abs(this.velocity.x) > 0.05 ||\n      Math.abs(this.velocity.y) > 0.05 ||\n      Math.abs(this.velocity.scale) > 0.05\n    ) {\n      // Update CSS `transform` value for the content element\n      this.transform();\n\n      // Next RAF\n      this.pendingAnimateUpdate = requestAnimationFrame(() => {\n        this.pendingAnimateUpdate = null;\n        this.animate();\n      });\n\n      // * Continue animation loop\n\n      return;\n    }\n\n    // * Stop animation\n\n    // Normalize values\n    this.current.x = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])(this.current.x + this.velocity.x / (1 / this.friction - 1));\n    this.current.y = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])(this.current.y + this.velocity.y / (1 / this.friction - 1));\n\n    if (Math.abs(this.current.x) < 0.5) {\n      this.current.x = 0;\n    }\n\n    if (Math.abs(this.current.y) < 0.5) {\n      this.current.y = 0;\n    }\n\n    this.current.scale = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])(this.current.scale + this.velocity.scale / (1 / this.friction - 1), 10000);\n\n    if (Math.abs(this.current.scale - 1) < 0.01) {\n      this.current.scale = 1;\n    }\n\n    this.state = \"ready\";\n\n    this.stopMoving();\n\n    this.transform();\n\n    this.handleCursor();\n\n    this.trigger(\"afterAnimate\");\n  }\n\n  /**\n   * Update the class name depending on whether the content is scaled\n   */\n  handleCursor() {\n    const draggableClass = this.option(\"draggableClass\");\n\n    if (!draggableClass || !this.option(\"touch\")) {\n      return;\n    }\n\n    if (\n      this.contentDim.width <= this.viewportDim.width &&\n      this.option(\"panOnlyZoomed\") == true &&\n      this.current.scale <= this.option(\"baseScale\")\n    ) {\n      this.$viewport.classList.remove(draggableClass);\n    } else {\n      this.$viewport.classList.add(draggableClass);\n    }\n  }\n\n  /**\n   * Check if content is dragged, zoomed or is animating to resting position\n   */\n  isMoved() {\n    return (\n      this.current.x !== 0 ||\n      this.current.y !== 0 ||\n      this.current.scale !== 1 ||\n      this.velocity.x > 0 ||\n      this.velocity.y > 0 ||\n      this.velocity.scale > 0\n    );\n  }\n\n  /**\n   * Reset velocity values to stop animation\n   */\n  stopMoving() {\n    this.velocity = {\n      x: 0,\n      y: 0,\n      scale: 0,\n    };\n  }\n\n  /**\n   * Update CSS `transform` property of content with current values,\n   * is executed at each step of the animation\n   */\n  transform() {\n    this.trigger(\"beforeTransform\");\n\n    const x = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])(this.current.x, 100);\n    const y = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])(this.current.y, 100);\n\n    const scale = Object(_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__[\"round\"])(this.current.scale, 10000);\n\n    if (Math.abs(x) <= 0.1 && Math.abs(y) <= 0.1 && Math.abs(scale - 1) <= 0.1) {\n      this.$content.style.transform = \"\";\n    } else {\n      // Sadly, `translate3d` causes image blurriness on Safari\n      this.$content.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;\n    }\n\n    this.trigger(\"afterTransform\");\n  }\n\n  /**\n   * Apply bounce force if boundary is reached\n   */\n  applyBoundForce() {\n    if (this.state !== \"decel\") {\n      return;\n    }\n\n    const resultForce = { x: 0, y: 0 };\n    const bounceForce = this.option(\"bounceForce\");\n\n    const boundX = this.boundX;\n    const boundY = this.boundY;\n\n    let pastLeft, pastRight, pastTop, pastBottom;\n\n    if (boundX) {\n      pastLeft = this.current.x < boundX.from;\n      pastRight = this.current.x > boundX.to;\n    }\n\n    if (boundY) {\n      pastTop = this.current.y < boundY.from;\n      pastBottom = this.current.y > boundY.to;\n    }\n\n    // Past left of right viewport boundaries\n    if (pastLeft || pastRight) {\n      const bound = pastLeft ? boundX.from : boundX.to;\n      const distance = bound - this.current.x;\n\n      let force = distance * bounceForce;\n\n      const restX = this.current.x + (this.velocity.x + force) / (1 / this.friction - 1);\n\n      if (!((pastLeft && restX < boundX.from) || (pastRight && restX > boundX.to))) {\n        force = distance * bounceForce - this.velocity.x;\n      }\n\n      resultForce.x = force;\n    }\n\n    // Past top of bottom viewport boundaries\n    if (pastTop || pastBottom) {\n      const bound = pastTop ? boundY.from : boundY.to;\n      const distance = bound - this.current.y;\n\n      let force = distance * bounceForce;\n\n      const restY = this.current.y + (this.velocity.y + force) / (1 / this.friction - 1);\n\n      if (!((pastTop && restY < boundY.from) || (pastBottom && restY > boundY.to))) {\n        force = distance * bounceForce - this.velocity.y;\n      }\n\n      resultForce.y = force;\n    }\n\n    this.velocity.x += resultForce.x;\n    this.velocity.y += resultForce.y;\n  }\n\n  /**\n   * Apply drag force to move content to drag position\n   */\n  applyDragForce() {\n    if (this.state !== \"dragging\") {\n      return;\n    }\n\n    this.velocity = {\n      x: (1 / this.friction - 1) * (this.drag.endPosition.x - this.current.x),\n      y: (1 / this.friction - 1) * (this.drag.endPosition.y - this.current.y),\n      scale: (1 / this.friction - 1) * (this.drag.endPosition.scale - this.current.scale),\n    };\n  }\n\n  /**\n   * Initialize `resizeObserver` and attach touch/mouse/click/wheel event listeners\n   */\n  attachEvents() {\n    const $viewport = this.$viewport;\n\n    // * Create and attach resize observer\n    this.resizeObserver =\n      this.resizeObserver ||\n      new _shared_utils_ResizeObserver_js__WEBPACK_IMPORTED_MODULE_2__[\"ResizeObserver\"]((entries) => {\n        this.pendingResizeUpdate =\n          this.pendingResizeUpdate ||\n          setTimeout(() => {\n            let rect = entries && entries[0].contentRect;\n\n            // Polyfill does not provide `contentRect`\n            if (!rect && this.$viewport) rect = this.$viewport.getBoundingClientRect();\n\n            // Check to see if there are any changes\n            if (\n              rect &&\n              (Math.abs(rect.width - this.viewportDim.width) > 1 || Math.abs(rect.height - this.viewportDim.height) > 1)\n            ) {\n              this.updateMetrics();\n            }\n\n            this.pendingResizeUpdate = null;\n          }, this.option(\"updateRate\", 250));\n      });\n\n    this.resizeObserver.observe($viewport);\n\n    $viewport.addEventListener(\"click\", this.onClick, { passive: false });\n    $viewport.addEventListener(\"wheel\", this.onWheel, { passive: false });\n\n    // * Add touch listeners\n\n    if (!this.option(\"touch\")) {\n      return;\n    }\n\n    // Check if pointer events are supported\n    if (window.PointerEvent) {\n      // Add Pointer Event Listener\n      $viewport.addEventListener(\"pointerdown\", this.onPointerDown, { passive: false });\n      $viewport.addEventListener(\"pointermove\", this.onPointerMove, { passive: false });\n      $viewport.addEventListener(\"pointerup\", this.onPointerUp);\n      $viewport.addEventListener(\"pointercancel\", this.onPointerUp);\n    } else {\n      // Add Touch Listeners\n      $viewport.addEventListener(\"touchstart\", this.onPointerDown, { passive: false });\n      $viewport.addEventListener(\"touchmove\", this.onPointerMove, { passive: false });\n      $viewport.addEventListener(\"touchend\", this.onPointerUp);\n      $viewport.addEventListener(\"touchcancel\", this.onPointerUp);\n\n      // Add Mouse Listeners\n      $viewport.addEventListener(\"mousedown\", this.onPointerDown);\n    }\n  }\n\n  /**\n   * Remove observation and detach event listeners\n   */\n  detachEvents() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this.resizeObserver = null;\n\n    if (this.pendingResizeUpdate) {\n      clearTimeout(this.pendingResizeUpdate);\n      this.pendingResizeUpdate = null;\n    }\n\n    const $viewport = this.$viewport;\n\n    if (window.PointerEvent) {\n      //  Pointer Event Listener\n      $viewport.removeEventListener(\"pointerdown\", this.onPointerDown, { passive: false });\n      $viewport.removeEventListener(\"pointermove\", this.onPointerMove, { passive: false });\n      $viewport.removeEventListener(\"pointerup\", this.onPointerUp);\n      $viewport.removeEventListener(\"pointercancel\", this.onPointerUp);\n    } else {\n      //  Touch Listeners\n      $viewport.removeEventListener(\"touchstart\", this.onPointerDown, { passive: false });\n      $viewport.removeEventListener(\"touchmove\", this.onPointerMove, { passive: false });\n      $viewport.removeEventListener(\"touchend\", this.onPointerUp);\n      $viewport.removeEventListener(\"touchcancel\", this.onPointerUp);\n\n      //  Mouse Listeners\n      $viewport.removeEventListener(\"mousedown\", this.onPointerDown);\n    }\n\n    $viewport.removeEventListener(\"click\", this.onClick, { passive: false });\n    $viewport.removeEventListener(\"wheel\", this.onWheel, { passive: false });\n  }\n\n  /**\n   * Make new pointer object from event data\n   * @param {Object} event\n   */\n  copyPointer(event) {\n    return {\n      pointerId: event.pointerId,\n      clientX: event.clientX,\n      clientY: event.clientY,\n    };\n  }\n\n  /**\n   * Find index of corresponding pointer object from event\n   * @param {Object} event\n   */\n  findPointerIndex(event) {\n    let i = this.pointers.length;\n\n    while (i--) {\n      if (this.pointers[i].pointerId === event.pointerId) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Add or update pointer object for each finger\n   * @param {Object} event\n   */\n  addPointer(event) {\n    let i = 0;\n\n    // Add touches if applicable\n    if (event.touches && event.touches.length) {\n      for (const touch of event.touches) {\n        touch.pointerId = i++;\n        this.addPointer(touch);\n      }\n\n      return;\n    }\n\n    i = this.findPointerIndex(event);\n\n    // Update if already present\n    if (i > -1) {\n      this.pointers.splice(i, 1);\n    }\n\n    this.pointers.push(event);\n  }\n\n  /**\n   * Remove corresponding pointer object\n   * @param {Object} event\n   */\n  removePointer(event) {\n    // Add touches if applicable\n    if (event.touches) {\n      // Remove all touches\n      while (this.pointers.length) {\n        this.pointers.pop();\n      }\n      return;\n    }\n\n    const i = this.findPointerIndex(event);\n\n    if (i > -1) {\n      this.pointers.splice(i, 1);\n    }\n  }\n\n  /**\n   * Get middle point from last two touch points,\n   * if there is only one point, then it is returned\n   */\n  getMiddlePoint() {\n    let pointers = [...this.pointers];\n\n    pointers = pointers.sort((a, b) => {\n      return b.pointerId - a.pointerId;\n    });\n\n    const pointer1 = pointers.shift();\n    const pointer2 = pointers.shift();\n\n    if (pointer2) {\n      return {\n        clientX: (pointer1.clientX - pointer2.clientX) * 0.5 + pointer2.clientX,\n        clientY: (pointer1.clientY - pointer2.clientY) * 0.5 + pointer2.clientY,\n      };\n    }\n\n    return {\n      clientX: pointer1 ? pointer1.clientX : 0,\n      clientY: pointer1 ? pointer1.clientY : 0,\n    };\n  }\n\n  /**\n   * Get distance between any touch points\n   * @param {Object} pointers\n   * @param {String} [axis]\n   */\n  getDistance(pointers, axis) {\n    pointers = pointers || [...this.pointers];\n    pointers = pointers.slice();\n\n    if (!pointers || pointers.length < 2) {\n      return 0;\n    }\n\n    pointers = pointers.sort((a, b) => {\n      return b.pointerId - a.pointerId;\n    });\n\n    const event1 = pointers.shift();\n    const event2 = pointers.shift();\n\n    const xDistance = Math.abs(event2.clientX - event1.clientX);\n\n    if (axis === \"x\") {\n      return xDistance;\n    }\n\n    const yDistance = Math.abs(event2.clientY - event1.clientY);\n\n    if (axis === \"y\") {\n      return yDistance;\n    }\n\n    return Math.sqrt(Math.pow(xDistance, 2) + Math.pow(yDistance, 2));\n  }\n\n  /**\n   * Stop dragging animation and freeze current state\n   */\n  resetDragState() {\n    const { left, top } = this.$content.getClientRects()[0];\n\n    const middlePoint = this.getMiddlePoint();\n\n    const currentPosition = {\n      top,\n      left,\n      x: this.current.x,\n      y: this.current.y,\n      scale: this.current.scale,\n    };\n\n    Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(this.drag, {\n      startPosition: Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])({}, currentPosition),\n      startPoint: Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])({}, middlePoint),\n      startDistance: this.getDistance(),\n\n      endPosition: Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])({}, currentPosition),\n      endPoint: Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])({}, middlePoint),\n\n      distance: 0,\n      distanceX: 0,\n      distanceY: 0,\n    });\n\n    if (this.state === \"pointerdown\") {\n      this.lockAxis = null;\n\n      this.drag.startTime = new Date();\n      this.drag.firstPosition = Object.assign({}, currentPosition);\n    }\n\n    this.stopMoving();\n\n    this.friction = this.option(\"friction\");\n  }\n\n  /**\n   * Handle `pointerdown`, `touchstart` or `mousedown` event\n   * @param {Event} event\n   */\n  onPointerDown(event) {\n    if (!event || (event.button && event.button > 0)) {\n      return;\n    }\n\n    // Improve UX - disable click events while zooming content that should be\n    // interactive only when zoomed in (e.g., from within carousel)\n    if (this.option(\"panOnlyZoomed\") && this.velocity.scale) {\n      event.preventDefault();\n      return;\n    }\n\n    this.resetDragState();\n\n    if (!this.pointers.length) {\n      // Allow touch action and click events on textareas inputs, selects and videos\n      let ignoreClickedElement =\n        [\"BUTTON\", \"TEXTAREA\", \"OPTION\", \"INPUT\", \"SELECT\", \"VIDEO\"].indexOf(event.target.nodeName) !== -1;\n\n      if (ignoreClickedElement) {\n        return;\n      }\n\n      // Allow text selection\n      if (this.option(\"textSelection\") && Object(_shared_utils_getTextNodeFromPoint_js__WEBPACK_IMPORTED_MODULE_5__[\"getTextNodeFromPoint\"])(event.target, event.clientX, event.clientY)) {\n        return;\n      }\n\n      // Allow scrolling\n      if (Object(_shared_utils_isScrollable_js__WEBPACK_IMPORTED_MODULE_4__[\"isScrollable\"])(event.target)) {\n        return;\n      }\n    }\n\n    Object(_shared_utils_clearTextSelection_js__WEBPACK_IMPORTED_MODULE_3__[\"clearTextSelection\"])();\n\n    if (this.pointers.length > 1 || (this.pointers.length && this.lockAxis)) {\n      event.preventDefault();\n\n      return;\n    }\n\n    if (this.trigger(\"touchStart\", event) === false) {\n      return;\n    }\n\n    event.preventDefault();\n\n    this.state = \"pointerdown\";\n\n    this.addPointer(this.copyPointer(event));\n\n    this.resetDragState();\n\n    // Add the move and end listeners\n    if (window.PointerEvent) {\n      try {\n        event.target.setPointerCapture(event.pointerId);\n      } catch (e) {}\n    } else {\n      // Add Mouse Listeners\n      document.addEventListener(\"mousemove\", this.onPointerMove, { passive: false });\n      document.addEventListener(\"mouseup\", this.onPointerUp, { passive: false });\n    }\n  }\n\n  /**\n   * Handle `pointermove`, `touchmove` or `mousemove` event\n   * @param {Event} event\n   */\n  onPointerMove(event) {\n    if (event.targetTouches && event.targetTouches.length > 1) {\n      return;\n    }\n\n    if (this.state !== \"pointerdown\" && this.state !== \"dragging\") {\n      return;\n    }\n\n    if (this.trigger(\"touchMove\", event) == false) {\n      event.preventDefault();\n      return;\n    }\n\n    this.addPointer(this.copyPointer(event));\n\n    if (this.pointers.length > 1 && this.option(\"pinchToZoom\") === false) {\n      return;\n    }\n\n    // Disable touch action if current zoom level is below base level\n    if (\n      this.option(\"panOnlyZoomed\") == true &&\n      this.current.scale === this.option(\"baseScale\") &&\n      this.pointers.length < 2\n    ) {\n      event.preventDefault();\n      return;\n    }\n\n    const dragEndPoint = this.getMiddlePoint();\n    const currentPoints = [dragEndPoint, this.drag.startPoint];\n\n    this.drag.distance = this.getDistance(currentPoints);\n\n    const hasClickEvent =\n      (this.events.click && this.events.click.length) ||\n      (this.events.doubleClick && this.events.doubleClick.length) ||\n      this.option.click ||\n      this.option.doubleClick;\n\n    if (this.drag.distance < 6 && (hasClickEvent || (this.option(\"lockAxis\") && !this.lockAxis))) {\n      return;\n    }\n\n    if (this.state == \"pointerdown\") {\n      this.state = \"dragging\";\n    }\n\n    if (this.state !== \"dragging\") {\n      return;\n    }\n\n    const axisToLock = this.option(\"lockAxis\");\n\n    if (!this.lockAxis && axisToLock) {\n      if (axisToLock === \"xy\") {\n        const distanceX = this.getDistance(currentPoints, \"x\");\n        const distanceY = this.getDistance(currentPoints, \"y\");\n\n        const angle = Math.abs((Math.atan2(distanceY, distanceX) * 180) / Math.PI);\n\n        this.lockAxis = angle > 45 && angle < 135 ? \"y\" : \"x\";\n      } else {\n        this.lockAxis = axisToLock;\n      }\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    this.$viewport.classList.add(this.option(\"draggingClass\"));\n\n    this.animate();\n\n    let scale = this.current.scale;\n\n    let dragOffsetX = 0;\n    let dragOffsetY = 0;\n\n    if (!(this.current.scale === this.option(\"baseScale\") && this.lockAxis === \"y\")) {\n      dragOffsetX = dragEndPoint.clientX - this.drag.startPoint.clientX;\n    }\n\n    if (!(this.current.scale === this.option(\"baseScale\") && this.lockAxis === \"x\")) {\n      dragOffsetY = dragEndPoint.clientY - this.drag.startPoint.clientY;\n    }\n\n    this.drag.endPosition.x = this.drag.startPosition.x + dragOffsetX;\n    this.drag.endPosition.y = this.drag.startPosition.y + dragOffsetY;\n\n    if (this.pointers.length > 1) {\n      // Store middle point for correct positioning after touch release (when zoom level exceeds max level)\n      this.drag.middlePoint = dragEndPoint;\n\n      scale = (this.drag.startPosition.scale * this.getDistance()) / this.drag.startDistance;\n      scale = Math.max(Math.min(scale, this.option(\"maxScale\") * 2), this.option(\"minScale\") * 0.5);\n\n      const width = this.$content.width;\n      const height = this.$content.height;\n\n      const startWidth = width * this.drag.startPosition.scale;\n      const startHeight = height * this.drag.startPosition.scale;\n\n      const nextWidth = width * scale;\n      const nextHeight = height * scale;\n\n      const percentXInStartBox = (this.drag.startPoint.clientX - this.drag.startPosition.left) / startWidth;\n      const percentYInStartBox = (this.drag.startPoint.clientY - this.drag.startPosition.top) / startHeight;\n\n      const deltaX = (nextWidth - startWidth) * (percentXInStartBox - 0.5);\n      const deltaY = (nextHeight - startHeight) * (percentYInStartBox - 0.5);\n\n      this.drag.endPosition.x -= deltaX;\n      this.drag.endPosition.y -= deltaY;\n\n      this.drag.endPosition.scale = scale;\n\n      this.updateBounds(scale);\n    }\n\n    this.applyDragResistance();\n  }\n\n  /**\n   * Handle `pointerup`, `touchend`, etc events\n   * @param {Event} event -\n   */\n  onPointerUp(event) {\n    this.removePointer(event);\n\n    // Remove Event Listeners\n    if (window.PointerEvent) {\n      try {\n        event.target.releasePointerCapture(event.pointerId);\n      } catch (e) {}\n    } else {\n      // Remove Mouse Listeners\n      document.removeEventListener(\"mousemove\", this.onPointerMove, { passive: false });\n      document.removeEventListener(\"mouseup\", this.onPointerUp, { passive: false });\n    }\n\n    // Skip when one finger is raised and the other is left\n    if (this.pointers.length > 0) {\n      event.preventDefault();\n\n      this.resetDragState();\n\n      return;\n    }\n\n    if (this.state !== \"pointerdown\" && this.state !== \"dragging\") {\n      return;\n    }\n\n    this.$viewport.classList.remove(this.option(\"draggingClass\"));\n\n    const { top, left } = this.$content.getClientRects()[0];\n    const drag = this.drag;\n\n    Object(_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(true, drag, {\n      elapsedTime: new Date() - drag.startTime,\n\n      distanceX: drag.endPosition.x - drag.firstPosition.x,\n      distanceY: drag.endPosition.y - drag.firstPosition.y,\n\n      endPosition: {\n        top,\n        left,\n      },\n    });\n\n    drag.distance = Math.sqrt(Math.pow(drag.distanceX, 2) + Math.pow(drag.distanceY, 2));\n\n    this.state = \"decel\";\n    this.friction = this.option(\"decelFriction\");\n\n    this.pan = {\n      x: this.current.x + this.velocity.x / (1 / this.friction - 1),\n      y: this.current.y + this.velocity.y / (1 / this.friction - 1),\n      scale: this.current.scale + this.velocity.scale / (1 / this.friction - 1),\n    };\n\n    if (this.trigger(\"touchEnd\", event) === false) {\n      return;\n    }\n\n    if (this.state !== \"decel\") {\n      return;\n    }\n\n    // * Check if scaled content past limits\n    // Below minimum\n    const minScale = this.option(\"minScale\");\n\n    if (this.current.scale < minScale) {\n      this.zoomTo(minScale, { friction: 0.64 });\n\n      return;\n    }\n\n    // Exceed maximum\n    const maxScale = this.option(\"maxScale\");\n\n    if (this.current.scale - maxScale > 0.01) {\n      const props = { friction: 0.64 };\n\n      if (drag.middlePoint) {\n        props.x = drag.middlePoint.clientX - left;\n        props.y = drag.middlePoint.clientY - top;\n      }\n\n      this.zoomTo(maxScale, props);\n    }\n  }\n\n  /**\n   * Drag resistance outside bounds\n   */\n  applyDragResistance() {\n    const boundX = this.boundX;\n    const boundY = this.boundY;\n\n    let pastLeft, pastRight, pastTop, pastBottom;\n\n    if (boundX) {\n      pastLeft = this.drag.endPosition.x < boundX.from;\n      pastRight = this.drag.endPosition.x > boundX.to;\n    }\n\n    if (boundY) {\n      pastTop = this.drag.endPosition.y < boundY.from;\n      pastBottom = this.drag.endPosition.y > boundY.to;\n    }\n\n    if (pastLeft || pastRight) {\n      const bound = pastLeft ? boundX.from : boundX.to;\n      const distance = this.drag.endPosition.x - bound;\n\n      this.drag.endPosition.x = bound + distance * 0.3;\n    }\n\n    if (pastTop || pastBottom) {\n      const bound = pastTop ? boundY.from : boundY.to;\n      const distance = this.drag.endPosition.y - bound;\n\n      this.drag.endPosition.y = bound + distance * 0.3;\n    }\n  }\n\n  /**\n   * Handle `wheel` event\n   * @param {Event} event\n   */\n  onWheel(event) {\n    if (this.trigger(\"wheel\", event) === false) {\n      return;\n    }\n\n    if (this.option(\"wheel\", event) == \"zoom\") {\n      this.zoomWithWheel(event);\n    }\n  }\n\n  /**\n   * Change zoom level depending on scroll direction\n   * @param {Event} event `wheel` event\n   */\n  zoomWithWheel(event) {\n    if (this.changedDelta === undefined) {\n      this.changedDelta = 0;\n    }\n\n    let scale = this.current.scale;\n\n    const delta = Math.max(-1, Math.min(1, -event.deltaY || -event.deltaX || event.wheelDelta || -event.detail));\n\n    if ((delta < 0 && scale <= this.option(\"minScale\")) || (delta > 0 && scale >= this.option(\"maxScale\"))) {\n      this.changedDelta += Math.abs(delta);\n\n      if (this.changedDelta > this.option(\"wheelLimit\")) {\n        return;\n      }\n    } else {\n      this.changedDelta = 0;\n    }\n\n    scale = (scale * (100 + delta * this.option(\"wheelFactor\"))) / 100;\n\n    event.preventDefault();\n\n    const { top, left } = this.$content.getClientRects()[0];\n\n    const x = event.clientX - left;\n    const y = event.clientY - top;\n\n    this.zoomTo(scale, { x, y });\n  }\n\n  /**\n   * Handle `click` event, detect double-click\n   * @param {Event} event\n   */\n  onClick(event) {\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    // Skip if text is selected\n    if (window.getSelection().toString().length) {\n      event.stopPropagation();\n      event.stopImmediatePropagation();\n      return;\n    }\n\n    // Check if container has changed position (for example, when current instance is inside another one)\n    if (\n      this.drag.startPosition &&\n      this.drag.endPosition &&\n      (Math.abs(this.drag.endPosition.top - this.drag.startPosition.top) > 1 ||\n        Math.abs(this.drag.endPosition.left - this.drag.startPosition.left) > 1)\n    ) {\n      event.stopPropagation();\n      event.stopImmediatePropagation();\n      return;\n    }\n\n    // Wait for minimum distance\n    if (this.drag.distance > (this.lockAxis ? 6 : 1)) {\n      event.preventDefault();\n\n      event.stopPropagation();\n      event.stopImmediatePropagation();\n      return;\n    }\n\n    // Calculate click positon\n    let x = null;\n    let y = null;\n\n    if (event.clientX !== undefined && event.clientY !== undefined) {\n      x = event.clientX - this.$content.getClientRects()[0].left;\n      y = event.clientY - this.$content.getClientRects()[0].top;\n    }\n\n    let hasDoubleClick = this.options.doubleClick;\n\n    // Check if there is any `doubleClick` event listener\n    if (!hasDoubleClick && this.events.doubleClick && this.events.doubleClick.length) {\n      hasDoubleClick = true;\n    }\n\n    if (!hasDoubleClick) {\n      if (this.trigger(\"click\", event) === false) {\n        return;\n      }\n\n      if (this.option(\"click\") === \"toggleZoom\") {\n        this.toggleZoom({ x, y });\n      }\n\n      return;\n    }\n\n    if (!this.clickTimer) {\n      this.lastClickEvent = event;\n\n      this.clickTimer = setTimeout(() => {\n        this.clickTimer = null;\n\n        if (this.trigger(\"click\", event) === false) {\n          return;\n        }\n\n        if (this.option(\"click\") === \"toggleZoom\") {\n          this.toggleZoom({ x, y });\n        }\n      }, this.option(\"clickDelay\"));\n\n      return;\n    }\n\n    if (this.getDistance([event, this.lastClickEvent]) >= 6) {\n      return;\n    }\n\n    clearTimeout(this.clickTimer);\n    this.clickTimer = null;\n\n    if (this.trigger(\"doubleClick\", event) === false) {\n      return;\n    }\n\n    if (this.option(\"doubleClick\") === \"toggleZoom\") {\n      this.toggleZoom({ x, y });\n    }\n  }\n\n  /**\n   * Clean up\n   */\n  destroy() {\n    if (this.state === \"destroy\") {\n      return;\n    }\n\n    this.state = \"destroy\";\n\n    this.$viewport.classList.remove(\"not-selectable\");\n\n    if (this.$content instanceof HTMLImageElement && !this.$content.complete) {\n      this.$content.onload = null;\n      this.$content.onerror = null;\n    }\n\n    if (this.pendingAnimateUpdate) {\n      cancelAnimationFrame(this.pendingAnimateUpdate);\n      this.pendingAnimateUpdate = null;\n    }\n\n    if (this.clickTimer) {\n      clearTimeout(this.clickTimer);\n      this.clickTimer = null;\n    }\n\n    this.detachEvents();\n\n    this.pointers = [];\n\n    this.resetValues();\n\n    this.$viewport = null;\n    this.$content = null;\n\n    this.options = {};\n    this.events = {};\n  }\n}\n\n// Expose version\nPanzoom.version = \"__VERSION__\";\n\n// Static properties are a recent addition that dont work in all browsers yet\nPanzoom.Plugins = _plugins_index_js__WEBPACK_IMPORTED_MODULE_8__[\"Plugins\"];\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Panzoom/Panzoom.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Panzoom/plugins/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Panzoom/plugins/index.js ***!
  \*****************************************************************/
/*! exports provided: Plugins */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plugins\", function() { return Plugins; });\nconst Plugins = {};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/Panzoom/plugins/index.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/Base/Base.js":
/*!************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/Base/Base.js ***!
  \************************************************************/
/*! exports provided: Base */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Base\", function() { return Base; });\n/* harmony import */ var _utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/extend.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/extend.js\");\n/* harmony import */ var _utils_resolve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resolve.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/resolve.js\");\n/* harmony import */ var _utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/isPlainObject.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js\");\n\n\n\n\n/**\n * Base class, all components inherit from this class\n */\nclass Base {\n  /**\n   * Base constructor\n   * @param {Object} [options] - Options as `key: value` pairs\n   */\n  constructor(options = {}) {\n    this.options = Object(_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(true, {}, options);\n\n    this.plugins = [];\n    this.events = {};\n\n    // * Prefill with initial events\n    for (const type of [\"on\", \"once\"]) {\n      for (const args of Object.entries(this.options[type] || {})) {\n        this[type](...args);\n      }\n    }\n  }\n\n  /**\n   * Retrieve option value by key, supports subkeys\n   * @param {String} key Option name\n   * @param {*} [fallback] Fallback value for non-existing key\n   * @returns {*}\n   */\n  option(key, fallback) {\n    // Make sure it is string\n    key = String(key);\n\n    let value = Object(_utils_resolve_js__WEBPACK_IMPORTED_MODULE_1__[\"resolve\"])(key, this.options);\n\n    // Allow to have functions as options\n    if (typeof value === \"function\") {\n      value = value.call(this, key);\n    }\n\n    return value === undefined ? fallback : value;\n  }\n\n  /**\n   * Simple l10n support - replaces object keys\n   * found in template with corresponding values\n   * @param {String} str String containing values to localize\n   * @param {Array} params Substitute parameters\n   * @returns {String}\n   */\n  localize(str, params = []) {\n    return String(str).replace(/\\{\\{(\\w+).?(\\w+)?\\}\\}/g, (match, key, subkey) => {\n      let rez = false;\n\n      // Plugins have `Plugin.l10n.KEY`\n      if (subkey) {\n        rez = this.option(`${key[0] + key.toLowerCase().substring(1)}.l10n.${subkey}`);\n      } else {\n        rez = this.option(`l10n.${key}`);\n      }\n\n      if (!rez) {\n        return key;\n      }\n\n      for (let index = 0; index < params.length; index++) {\n        rez = rez.split(params[index][0]).join(params[index][1]);\n      }\n\n      return rez;\n    });\n  }\n\n  /**\n   * Subscribe to an event\n   * @param {String} name\n   * @param {Function} callback\n   * @returns {Object}\n   */\n  on(name, callback) {\n    if (Object(_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_2__[\"isPlainObject\"])(name)) {\n      for (const args of Object.entries(name)) {\n        this.on(...args);\n      }\n\n      return this;\n    }\n\n    String(name)\n      .split(\" \")\n      .forEach((item) => {\n        const listeners = (this.events[item] = this.events[item] || []);\n\n        if (listeners.indexOf(callback) == -1) {\n          listeners.push(callback);\n        }\n      });\n\n    return this;\n  }\n\n  /**\n   * Subscribe to an event only once\n   * @param {String} name\n   * @param {Function} callback\n   * @returns {Object}\n   */\n  once(name, callback) {\n    if (Object(_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_2__[\"isPlainObject\"])(name)) {\n      for (const args of Object.entries(name)) {\n        this.once(...args);\n      }\n\n      return this;\n    }\n\n    String(name)\n      .split(\" \")\n      .forEach((item) => {\n        const listener = (...details) => {\n          this.off(item, listener);\n          callback.call(this, this, ...details);\n        };\n\n        listener._ = callback;\n\n        this.on(item, listener);\n      });\n\n    return this;\n  }\n\n  /**\n   * Unsubscribe event with name and callback\n   * @param {String} name\n   * @param {Function} callback\n   * @returns {Object}\n   */\n  off(name, callback) {\n    if (Object(_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_2__[\"isPlainObject\"])(name)) {\n      for (const args of Object.entries(name)) {\n        this.off(...args);\n      }\n\n      return;\n    }\n\n    name.split(\" \").forEach((item) => {\n      const listeners = this.events[item];\n\n      if (!listeners || !listeners.length) {\n        return this;\n      }\n\n      let index = -1;\n\n      for (let i = 0, len = listeners.length; i < len; i++) {\n        const listener = listeners[i];\n\n        if (listener && (listener === callback || listener._ === callback)) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index != -1) {\n        listeners.splice(index, 1);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Emit an event.\n   * If present, `\"*\"` handlers are invoked after name-matched handlers.\n   * @param {String} name\n   * @param  {...any} details\n   * @returns {Boolean}\n   */\n  trigger(name, ...details) {\n    for (const listener of [...(this.events[name] || [])].slice()) {\n      if (listener && listener.call(this, this, ...details) === false) {\n        return false;\n      }\n    }\n\n    // A wildcard \"*\" event type\n    for (const listener of [...(this.events[\"*\"] || [])].slice()) {\n      if (listener && listener.call(this, name, this, ...details) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Add given plugins to this instance,\n   * this will end up calling `attach` method of each plugin\n   * @param {Object} Plugins\n   * @returns {Object}\n   */\n  attachPlugins(plugins) {\n    const newPlugins = {};\n\n    for (const [key, Plugin] of Object.entries(plugins || {})) {\n      // Check if this plugin is not disabled by option\n      if (this.options[key] !== false) {\n        // Populate options with defaults from the plugin\n        this.options[key] = Object(_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])({}, Plugin.defaults || {}, this.options[key]);\n\n        // Initialise plugin\n        newPlugins[key] = new Plugin(this);\n      }\n    }\n\n    for (const [key, plugin] of Object.entries(newPlugins)) {\n      plugin.attach(this);\n    }\n\n    this.plugins = Object.assign({}, this.plugins, newPlugins);\n\n    return this;\n  }\n\n  /**\n   * Remove all plugin instances from this instance,\n   * this will end up calling `detach` method of each plugin\n   * @returns {Object}\n   */\n  detachPlugins() {\n    for (const key in this.plugins) {\n      let plugin;\n\n      if ((plugin = this.plugins[key]) && typeof plugin.detach === \"function\") {\n        plugin.detach(this);\n      }\n    }\n\n    this.plugins = {};\n\n    return this;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/Base/Base.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/ResizeObserver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/ResizeObserver.js ***!
  \***********************************************************************/
/*! exports provided: ResizeObserver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResizeObserver\", function() { return ResizeObserver; });\n/**\n * ResizeObserver Polyfill\n */\nconst ResizeObserver =\n  (typeof window !== \"undefined\" && window.ResizeObserver) ||\n  class {\n    constructor(callback) {\n      this.observables = [];\n      // Array of observed elements that looks like this:\n      // [{\n      //   el: domNode,\n      //   size: {height: x, width: y}\n      // }]\n      this.boundCheck = this.check.bind(this);\n      this.boundCheck();\n      this.callback = callback;\n    }\n\n    observe(el) {\n      if (this.observables.some((observable) => observable.el === el)) {\n        return;\n      }\n\n      const newObservable = {\n        el: el,\n        size: {\n          height: el.clientHeight,\n          width: el.clientWidth,\n        },\n      };\n\n      this.observables.push(newObservable);\n    }\n\n    unobserve(el) {\n      this.observables = this.observables.filter((obj) => obj.el !== el);\n    }\n\n    disconnect() {\n      this.observables = [];\n    }\n\n    check() {\n      const changedEntries = this.observables\n        .filter((obj) => {\n          const currentHeight = obj.el.clientHeight;\n          const currentWidth = obj.el.clientWidth;\n          if (obj.size.height !== currentHeight || obj.size.width !== currentWidth) {\n            obj.size.height = currentHeight;\n            obj.size.width = currentWidth;\n            return true;\n          }\n        })\n        .map((obj) => obj.el);\n\n      if (changedEntries.length > 0) {\n        this.callback(changedEntries);\n      }\n\n      window.requestAnimationFrame(this.boundCheck);\n    }\n  };\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/ResizeObserver.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/canUseDOM.js":
/*!******************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/canUseDOM.js ***!
  \******************************************************************/
/*! exports provided: canUseDOM */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canUseDOM\", function() { return canUseDOM; });\n/**\r\n * Detect if rendering from the client or the server\r\n */\r\nconst canUseDOM = !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\r\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/canUseDOM.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/clearTextSelection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/clearTextSelection.js ***!
  \***************************************************************************/
/*! exports provided: clearTextSelection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearTextSelection\", function() { return clearTextSelection; });\n/**\n *  Deselect any text which may be selected on a page\n */\nconst clearTextSelection = () => {\n  const selection = window.getSelection ? window.getSelection() : document.selection;\n\n  if (selection && selection.rangeCount && selection.getRangeAt(0).getClientRects().length) {\n    if (selection.removeAllRanges) {\n      selection.removeAllRanges();\n    } else if (selection.empty) {\n      selection.empty();\n    }\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/clearTextSelection.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/extend.js":
/*!***************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/extend.js ***!
  \***************************************************************/
/*! exports provided: extend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extend\", function() { return extend; });\n/* harmony import */ var _isPlainObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isPlainObject.js */ \"./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js\");\n\n\n/**\n * Merge the contents of two or more objects together into the first object.\n * If passing \"true\" for first argument, the merge becomes recursive (aka. deep copy).\n * @param  {...any} args\n * @returns {Object}\n */\nconst extend = (...args) => {\n  let deep = false;\n\n  if (typeof args[0] == \"boolean\") {\n    deep = args.shift();\n  }\n\n  let result = args[0];\n\n  if (!result || typeof result !== \"object\") {\n    throw new Error(\"extendee must be an object\");\n  }\n\n  const extenders = args.slice(1);\n  const len = extenders.length;\n\n  for (let i = 0; i < len; i++) {\n    const extender = extenders[i];\n\n    for (let key in extender) {\n      if (extender.hasOwnProperty(key)) {\n        const value = extender[key];\n\n        if (deep && (Array.isArray(value) || Object(_isPlainObject_js__WEBPACK_IMPORTED_MODULE_0__[\"isPlainObject\"])(value))) {\n          const base = Array.isArray(value) ? [] : {};\n\n          result[key] = extend(true, result.hasOwnProperty(key) ? result[key] : base, value);\n        } else {\n          result[key] = value;\n        }\n      }\n    }\n  }\n\n  return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/extend.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/getDimensions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/getDimensions.js ***!
  \**********************************************************************/
/*! exports provided: getFullWidth, getFullHeight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFullWidth\", function() { return getFullWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFullHeight\", function() { return getFullHeight; });\n/**\n * Get actual width of the element, regardless of how much of content is currently visible\n * @param {Element} elem\n * @returns {Integer}\n */\nconst getFullWidth = (elem) => {\n  let rez = 0;\n\n  if (elem) {\n    if (elem instanceof SVGElement) {\n      rez = Math.min(elem.getClientRects()[0].width, elem.width.baseVal.value);\n    } else {\n      rez = Math.max(elem.offsetWidth, elem.scrollWidth);\n    }\n  }\n\n  return rez;\n};\n\n/**\n * Get actual height of the element, regardless of how much of content is currently visible\n * @param {Element} elem\n * @returns {Integer}\n */\nconst getFullHeight = (elem) => {\n  let rez = 0;\n\n  if (elem) {\n    if (elem instanceof SVGElement) {\n      rez = Math.min(elem.getClientRects()[0].height, elem.height.baseVal.value);\n    } else {\n      rez = Math.max(elem.offsetHeight, elem.scrollHeight);\n    }\n  }\n\n  return rez;\n};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/getDimensions.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/getTextNodeFromPoint.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/getTextNodeFromPoint.js ***!
  \*****************************************************************************/
/*! exports provided: getTextNodeFromPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTextNodeFromPoint\", function() { return getTextNodeFromPoint; });\n/**\n * Get element child node at the given coordinates\n * @param {Element} HTML element\n * @param {Float|Integer} x\n * @param {Float|Integer} y\n * @returns {Node|Boolean}}\n */\nconst getTextNodeFromPoint = (element, x, y) => {\n  const nodes = element.childNodes;\n  const range = document.createRange();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (node.nodeType !== Node.TEXT_NODE) {\n      continue;\n    }\n\n    range.selectNodeContents(node);\n\n    const rect = range.getBoundingClientRect();\n\n    if (x >= rect.left && y >= rect.top && x <= rect.right && y <= rect.bottom) {\n      return node;\n    }\n  }\n\n  return false;\n};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/getTextNodeFromPoint.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js ***!
  \**********************************************************************/
/*! exports provided: isPlainObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPlainObject\", function() { return isPlainObject; });\n/**\n * Check to see if an object is a plain object (created using \"{}\" or \"new Object\").\n * @param {*} obj Variable of any type\n * @returns {Boolean}\n */\nconst isPlainObject = (obj) => {\n  return (\n    // separate from primitives\n    typeof obj === \"object\" &&\n    // is obvious\n    obj !== null &&\n    // separate instances (Array, DOM, ...)\n    obj.constructor === Object &&\n    // separate build-in like Math\n    Object.prototype.toString.call(obj) === \"[object Object]\"\n  );\n};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/isScrollable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/isScrollable.js ***!
  \*********************************************************************/
/*! exports provided: hasScrollbars, isScrollable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasScrollbars\", function() { return hasScrollbars; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isScrollable\", function() { return isScrollable; });\n/**\n * Check if  element has scrollable content\n * @param {Node} node\n * @returns {Boolean}\n */\nconst hasScrollbars = function (node) {\n  const overflowY = window.getComputedStyle(node)[\"overflow-y\"],\n    overflowX = window.getComputedStyle(node)[\"overflow-x\"],\n    vertical = (overflowY === \"scroll\" || overflowY === \"auto\") && Math.abs(node.scrollHeight - node.clientHeight) > 1,\n    horizontal = (overflowX === \"scroll\" || overflowX === \"auto\") && Math.abs(node.scrollWidth - node.clientWidth) > 1;\n\n  return vertical || horizontal;\n};\n\n/**\n * Check if element or one of the parents is scrollable\n * @param {Node} node  DOM Node element\n * @returns {Boolean}\n */\nconst isScrollable = function (node) {\n  if (!node || node.classList.contains(\"carousel__track\") || node === document.body) {\n    return false;\n  }\n\n  if (hasScrollbars(node)) {\n    return node;\n  }\n\n  return isScrollable(node.parentNode);\n};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/isScrollable.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/resolve.js":
/*!****************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/resolve.js ***!
  \****************************************************************/
/*! exports provided: resolve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resolve\", function() { return resolve; });\n/**\n * Access nested JavaScript objects by string path.\n * Example: `resolve(\"a.b.c\", {a:{b:{c:\"d\"}})` would return `d`\n * @param {String} path\n * @param {Object} obj\n * @returns {*}\n */\nconst resolve = function (path, obj) {\n  return path.split(\".\").reduce(function (prev, curr) {\n    return prev[curr];\n  }, obj);\n};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/resolve.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/round.js":
/*!**************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/round.js ***!
  \**************************************************************/
/*! exports provided: round */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/**\n * Round half up; to be more specific and to ensure things like 1.005 round correctly\n * @param {Float} value\n * @param {Integer} precision\n * @returns {Float}\n */\nconst round = (value, precision = 1000) => {\n  value = parseFloat(value) || 0;\n\n  return Math.round((value + Number.EPSILON) * precision) / precision;\n};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/round.js?");

/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/throttle.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/throttle.js ***!
  \*****************************************************************/
/*! exports provided: throttle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"throttle\", function() { return throttle; });\n/**\n * Throttling enforces a maximum number of times a function can be called over time\n * @param {Function} func Callback function\n * @param {Integer} limit Milliseconds\n * @returns {Function}\n */\nconst throttle = (func, limit) => {\n  let lastCall = 0;\n\n  return function (...args) {\n    const now = new Date().getTime();\n\n    if (now - lastCall < limit) {\n      return;\n    }\n\n    lastCall = now;\n\n    return func(...args);\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/@fancyapps/ui/src/shared/utils/throttle.js?");

/***/ })

}]);